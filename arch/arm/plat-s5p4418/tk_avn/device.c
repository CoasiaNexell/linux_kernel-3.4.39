/*
 * (C) Copyright 2009
 * jung hyun kim, Nexell Co, <jhkim@nexell.co.kr>
 *
 * See file CREDITS for list of people who contributed to this
 * project.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/types.h>
#include <linux/platform_device.h>
#include <linux/power_supply.h>
#include <linux/irq.h>
#include <linux/amba/pl022.h>

/* nexell soc headers */
#include <mach/platform.h>
#include <mach/devices.h>
#include <mach/soc.h>

#if defined(CONFIG_NXP_HDMI_CEC)
#include <mach/nxp-hdmi-cec.h>
#endif


extern void init_bcm_wifi(void);


// tnn s
#define BMPSIZE_1024_600
#if defined(BMPSIZE_1024_600)
	int line_data[][2] = {
	{76,209},{76,815},{77,209},{77,815},{78,208},{78,816},{79,208},{79,816},{80,207},{80,817},{81,207},{81,817},{82,206},{82,818},
	{83,206},{83,818},{84,205},{84,819},{85,205},{85,819},{86,204},{86,820},{87,204},{87,216},{87,808},{87,820},{88,203},{88,216},
	{88,808},{88,821},{89,203},{89,215},{89,809},{89,821},{90,203},{90,215},{90,809},{90,821},{91,202},{91,215},{91,810},{91,822},
	{92,202},{92,214},{92,810},{92,822},{93,201},{93,214},{93,811},{93,823},{94,201},{94,213},{94,811},{94,823},{95,200},{95,213},
	{95,812},{95,824},{96,200},{96,212},{96,812},{96,824},{97,199},{97,212},{97,813},{97,825},{98,199},{98,211},{98,813},{98,825},
	{99,198},{99,210},{99,814},{99,826},{100,198},{100,210},{100,814},{100,826},{101,197},{101,209},{101,815},{101,827},{102,197},
	{102,209},{102,815},{102,827},{103,196},{103,208},{103,816},{103,828},{104,196},{104,208},{104,816},{104,828},{105,195},{105,208},{105,816},
	{105,829},{106,195},{106,207},{106,817},{106,829},{107,195},{107,207},{107,817},{107,829},{108,194},{108,206},{108,818},{108,830},{109,194},
	{109,206},{109,818},{109,830},{110,193},{110,205},{110,819},{110,831},{111,193},{111,205},{111,819},{111,831},{112,192},{112,204},{112,820},
	{112,832},{113,192},{113,204},{113,820},{113,832},{114,191},{114,203},{114,821},{114,833},{115,191},{115,203},{115,821},{115,833},{116,190},
	{116,202},{116,822},{116,834},{117,190},{117,834},{118,189},{118,835},{119,189},{119,835},{120,188},{120,836},{121,188},{121,836},{122,187},
	{122,837},{123,187},{123,837},{124,187},{124,838},{125,186},{125,838},{126,186},{126,839},{127,185},{127,839},{128,185},{128,197},{128,827},
	{128,840},{129,184},{129,196},{129,828},{129,840},{130,184},{130,196},{130,828},{130,840},{131,183},{131,195},{131,829},{131,841},{132,183},
	{132,195},{132,829},{132,841},{133,182},{133,195},{133,830},{133,842},{134,182},{134,194},{134,830},{134,842},{135,181},{135,194},{135,831},
	{135,843},{136,181},{136,193},{136,831},{136,843},{137,180},{137,193},{137,832},{137,844},{138,180},{138,192},{138,832},{138,844},{139,179},
	{139,192},{139,832},{139,845},{140,179},{140,191},{140,833},{140,845},{141,179},{141,191},{141,833},{141,845},{142,178},{142,190},{142,834},
	{142,846},{143,178},{143,190},{143,834},{143,846},{144,177},{144,189},{144,835},{144,847},{145,177},{145,189},{145,835},{145,847},{146,176},
	{146,188},{146,836},{146,848},{147,176},{147,188},{147,836},{147,848},{148,175},{148,187},{148,837},{148,849},{149,175},{149,187},{149,837},
	{149,849},{150,174},{150,186},{150,838},{150,850},{151,174},{151,186},{151,838},{151,850},{152,173},{152,185},{152,839},{152,851},{153,173},
	{153,185},{153,839},{153,851},{154,172},{154,184},{154,840},{154,852},{155,172},{155,184},{155,840},{155,852},{156,171},{156,184},{156,840},
	{156,853},{157,171},{157,183},{157,841},{157,853},{158,171},{158,183},{158,841},{158,853},{159,170},{159,182},{159,842},{159,854},{160,170},
	{160,182},{160,842},{160,854},{161,169},{161,181},{161,843},{161,855},{162,169},{162,181},{162,843},{162,855},{163,168},{163,180},{163,844},
	{163,856},{164,168},{164,180},{164,844},{164,856},{165,167},{165,179},{165,845},{165,857},{166,167},{166,179},{166,845},{166,857},{167,166},
	{167,178},{167,846},{167,858},{168,166},{168,178},{168,846},{168,858},{169,165},{169,177},{169,847},{169,859},{170,165},{170,177},{170,847},
	{170,859},{171,164},{171,176},{171,848},{171,860},{172,164},{172,176},{172,848},{172,860},{173,163},{173,176},{173,848},{173,861},{174,163},
	{174,175},{174,849},{174,861},{175,163},{175,175},{175,849},{175,861},{176,162},{176,174},{176,850},{176,862},{177,162},{177,862},{178,161},
	{178,863},{179,161},{179,863},{180,160},{180,864},{181,160},{181,864},{182,159},{182,865},{183,159},{183,865},{184,158},{184,866},{185,158},
	{185,866},{186,157},{186,867},{187,157},{187,169},{187,855},{187,867},{188,156},{188,169},{188,855},{188,868},{189,156},{189,168},{189,856},
	{189,868},{190,155},{190,168},{190,856},{190,869},{191,155},{191,167},{191,857},{191,869},{192,155},{192,167},{192,857},{192,869},{193,154},
	{193,166},{193,858},{193,870},{194,154},{194,166},{194,858},{194,870},{195,153},{195,165},{195,859},{195,871},{196,153},{196,165},{196,859},
	{196,871},{197,152},{197,165},{197,860},{197,872},{198,152},{198,164},{198,860},{198,872},{199,151},{199,163},{199,861},{199,873},{200,151},
	{200,163},{200,861},{200,873},{201,150},{201,162},{201,862},{201,874},{202,150},{202,162},{202,862},{202,874},{203,149},{203,161},{203,863},
	{203,875},{204,149},{204,161},{204,863},{204,875},{205,148},{205,160},{205,864},{205,876},{206,148},{206,160},{206,864},{206,876},{207,147},
	{207,160},{207,864},{207,877},{208,147},{208,159},{208,865},{208,877},{209,147},{209,159},{209,865},{209,877},{210,146},{210,158},{210,866},
	{210,878},{211,146},{211,158},{211,866},{211,878},{212,145},{212,157},{212,867},{212,879},{213,145},{213,157},{213,867},{213,879},{214,144},
	{214,156},{214,868},{214,880},{215,144},{215,156},{215,868},{215,880},{216,143},{216,155},{216,869},{216,881},{217,143},{217,155},{217,869},
	{217,881},{218,142},{218,154},{218,870},{218,882},{219,142},{219,154},{219,870},{219,882},{220,141},{220,153},{220,871},{220,883},{221,141},
	{221,153},{221,871},{221,883},{222,140},{222,152},{222,872},{222,884},{223,140},{223,152},{223,872},{223,884},{224,139},{224,152},{224,872},
	{224,885},{225,139},{225,151},{225,873},{225,885},{226,139},{226,151},{226,873},{226,885},{227,138},{227,150},{227,874},{227,886},{228,138},
	{228,150},{228,874},{228,886},{229,137},{229,149},{229,875},{229,887},{230,137},{230,149},{230,875},{230,887},{231,136},{231,148},{231,876},
	{231,888},{232,136},{232,148},{232,876},{232,888},{233,135},{233,147},{233,877},{233,889},{234,135},{234,147},{234,877},{234,889},{235,134},
	{235,146},{235,878},{235,890},{236,134},{236,146},{236,878},{236,890},{237,133},{237,145},{237,879},{237,891},{238,133},{238,145},{238,879},
	{238,891},{239,132},{239,144},{239,880},{239,892},{240,132},{240,144},{240,880},{240,892},{241,131},{241,144},{241,880},{241,893},{242,131},
	{242,143},{242,881},{242,893},{243,131},{243,143},{243,881},{243,893},{244,130},{244,142},{244,882},{244,894},{245,130},{245,142},{245,882},
	{245,894},{246,129},{246,141},{246,883},{246,895},{247,129},{247,141},{247,883},{247,895},{248,128},{248,140},{248,884},{248,896},{249,128},
	{249,140},{249,884},{249,896},{250,127},{250,897},{251,127},{251,897},{252,126},{252,898},{253,126},{253,898},{254,125},{254,899},{255,125},
	{255,899},{256,124},{256,900},{257,124},{257,900},{258,123},{258,901},{259,123},{259,901},{260,123},{260,901},{261,122},{261,134},{261,890},
	{261,902},{262,122},{262,134},{262,890},{262,902},{263,121},{263,133},{263,891},{263,903},{264,121},{264,133},{264,891},{264,903},{265,120},
	{265,132},{265,892},{265,904},{266,120},{266,132},{266,892},{266,904},{267,119},{267,132},{267,893},{267,905},{268,119},{268,131},{268,893},
	{268,905},{269,118},{269,131},{269,894},{269,906},{270,118},{270,130},{270,894},{270,906},{271,117},{271,130},{271,895},{271,907},{272,117},
	{272,129},{272,895},{272,907},{273,116},{273,128},{273,896},{273,908},{274,116},{274,128},{274,896},{274,908},{275,115},{275,128},{275,896},
	{275,909},{276,115},{276,127},{276,897},{276,909},{277,115},{277,127},{277,897},{277,909},{278,114},{278,126},{278,898},{278,910},{279,114},
	{279,126},{279,898},{279,910},{280,113},{280,125},{280,899},{280,911},{281,113},{281,125},{281,899},{281,911},{282,112},{282,124},{282,900},
	{282,912},{283,112},{283,124},{283,900},{283,912},{284,111},{284,123},{284,901},{284,913},{285,111},{285,123},{285,901},{285,913},{286,110},
	{286,122},{286,902},{286,914},{287,110},{287,122},{287,902},{287,914},{288,109},{288,121},{288,903},{288,915},{289,109},{289,121},{289,903},
	{289,915},{290,108},{290,120},{290,904},{290,916},{291,108},{291,120},{291,904},{291,916},{292,107},{292,120},{292,904},{292,917},{293,107},
	{293,119},{293,905},{293,917},{294,107},{294,119},{294,905},{294,917},{295,106},{295,118},{295,906},{295,918},{296,106},{296,118},{296,906},
	{296,918},{297,105},{297,117},{297,907},{297,919},{298,105},{298,117},{298,907},{298,919},{299,104},{299,116},{299,908},{299,920},{300,104},
	{300,116},{300,908},{300,920},{301,103},{301,115},{301,909},{301,921},{302,103},{302,115},{302,909},{302,921},{303,102},{303,114},{303,910},
	{303,922},{304,102},{304,114},{304,910},{304,922},{305,101},{305,113},{305,911},{305,923},{306,101},{306,113},{306,911},{306,923},{307,100},
	{307,112},{307,912},{307,924},{308,100},{308,112},{308,912},{308,924},{309,99},{309,112},{309,912},{309,925},{310,99},{310,111},{310,913},
	{310,925},{311,99},{311,111},{311,913},{311,925},{312,98},{312,110},{312,914},{312,926},{313,98},{313,110},{313,914},{313,926},{314,97},
	{314,109},{314,915},{314,927},{315,97},{315,109},{315,915},{315,927},{316,96},{316,108},{316,916},{316,928},{317,96},{317,108},{317,916},
	{317,928},{318,95},{318,107},{318,917},{318,929},{319,95},{319,107},{319,917},{319,929},{320,94},{320,106},{320,918},{320,930},{321,94},
	{321,106},{321,918},{321,930},{322,93},{322,105},{322,919},{322,931},{323,93},{323,105},{323,919},{323,931},{324,92},{324,104},{324,920},
	{324,932},{325,92},{325,104},{325,920},{325,932},{326,91},{326,104},{326,920},{326,933},{327,91},{327,103},{327,921},{327,933},{328,91},
	{328,103},{328,921},{328,933},{329,90},{329,102},{329,922},{329,934},{330,90},{330,102},{330,922},{330,934},{331,89},{331,101},{331,923},
	{331,935},{332,89},{332,101},{332,923},{332,935},{333,88},{333,100},{333,924},{333,936},{334,88},{334,100},{334,924},{334,936},{335,87},
	{335,99},{335,925},{335,937},{336,87},{336,99},{336,925},{336,937},{337,86},{337,98},{337,926},{337,938},{338,86},{338,98},{338,926},
	{338,938},{339,85},{339,97},{339,927},{339,939},{340,85},{340,97},{340,927},{340,939},{341,84},{341,96},{341,928},{341,940},{342,84},
	{342,96},{342,928},{342,940},{343,83},{343,96},{343,928},{343,941},{344,83},{344,941},{345,83},{345,941},{346,82},{346,942},{347,82},
	{347,942},{348,81},{348,943},{349,81},{349,943},{350,80},{350,944},{351,80},{351,944},{352,79},{352,945},{353,79},{353,945},{354,78},
	{354,946},{355,78},{355,91},{355,933},{355,946},{356,77},{356,90},{356,934},{356,947},{357,77},{357,90},{357,934},{357,947},{358,76},
	{358,89},{358,935},{358,948},{359,76},{359,89},{359,935},{359,948},{360,75},{360,88},{360,936},{360,949},{361,75},{361,88},{361,936},
	{361,949},{362,75},{362,87},{362,937},{362,949},{363,74},{363,87},{363,937},{363,950},{364,74},{364,86},{364,938},{364,950},{365,73},
	{365,86},{365,938},{365,951},{366,73},{366,85},{366,939},{366,951},{367,72},{367,84},{367,940},{367,952},{368,72},{368,84},{368,940},
	{368,952},{369,71},{369,83},{369,941},{369,953},{370,71},{370,83},{370,941},{370,953},{371,70},{371,82},{371,942},{371,954},{372,70},
	{372,82},{372,942},{372,954},{373,69},{373,81},{373,943},{373,955},{374,69},{374,81},{374,943},{374,955},{375,68},{375,80},{375,944},
	{375,956},{376,68},{376,80},{376,944},{376,956},{377,67},{377,80},{377,944},{377,957},{378,67},{378,79},{378,945},{378,957},{379,67},
	{379,79},{379,945},{379,957},{380,66},{380,78},{380,946},{380,958},{381,66},{381,78},{381,946},{381,958},{382,65},{382,77},{382,947},
	{382,959},{383,65},{383,77},{383,947},{383,959},{384,64},{384,76},{384,948},{384,960},{385,64},{385,76},{385,948},{385,960},{386,63},
	{386,75},{386,949},{386,961},{387,63},{387,75},{387,949},{387,961},{388,62},{388,74},{388,950},{388,962},{389,62},{389,74},{389,950},
	{389,962},{390,61},{390,73},{390,951},{390,963},{391,61},{391,73},{391,951},{391,963},{392,60},{392,72},{392,952},{392,964},{393,60},
	{393,72},{393,952},{393,964},{394,59},{394,72},{394,952},{394,965},{395,59},{395,71},{395,953},{395,965},{396,59},{396,71},{396,953},
	{396,965},{397,58},{397,70},{397,954},{397,966},{398,58},{398,70},{398,954},{398,966},{399,57},{399,69},{399,955},{399,967},{400,57},
	{400,69},{400,955},{400,967},{401,56},{401,68},{401,956},{401,968},{402,56},{402,68},{402,956},{402,968},{403,55},{403,67},{403,957},
	{403,969},{404,55},{404,67},{404,957},{404,969},{405,54},{405,66},{405,958},{405,970},{406,54},{406,66},{406,958},{406,970},{407,53},
	{407,65},{407,959},{407,971},{408,53},{408,65},{408,959},{408,971},{409,52},{409,64},{409,960},{409,972},{410,52},{410,64},{410,960},
	{410,972},{411,51},{411,64},{411,960},{411,973},{412,51},{412,63},{412,961},{412,973},{413,51},{413,63},{413,961},{413,973},{414,50},
	{414,62},{414,962},{414,974},{415,50},{415,62},{415,962},{415,974},{416,49},{416,61},{416,963},{416,975},{417,49},{417,61},{417,963},
	{417,975},{418,48},{418,60},{418,964},{418,976},{419,48},{419,60},{419,964},{419,976},{420,47},{420,59},{420,965},{420,977},{421,47},
	{421,59},{421,965},{421,977},{422,46},{422,58},{422,966},{422,978},{423,46},{423,58},{423,966},{423,978},{424,45},{424,57},{424,967},
	{424,979},{425,45},{425,57},{425,967},{425,979},{426,44},{426,56},{426,968},{426,980},{427,44},{427,56},{427,968},{427,980},{428,43},
	{428,56},{428,968},{428,981},{429,43},{429,55},{429,969},{429,981},{430,43},{430,55},{430,969},{430,981},{431,42},{431,54},{431,970},
	{431,982},{432,42},{432,54},{432,970},{432,982},{433,41},{433,53},{433,971},{433,983},{434,41},{434,53},{434,971},{434,983},{435,40},
	{435,52},{435,972},{435,984},{436,40},{436,52},{436,972},{436,984},{437,39},{437,51},{437,973},{437,985},{438,39},{438,51},{438,973},
	{438,985},{439,38},{439,50},{439,974},{439,986},{440,38},{440,50},{440,974},{440,986},{441,37},{441,49},{441,975},{441,987},{442,37},
	{442,49},{442,975},{442,987},{443,36},{443,48},{443,976},{443,988},{444,36},{444,48},{444,976},{444,988},{445,35},{445,48},{445,976},
	{445,989},{446,35},{446,47},{446,977},{446,989},{447,35},{447,47},{447,977},{447,989},{448,34},{448,46},{448,978},{448,990},{449,34},
	{449,46},{449,978},{449,990},{450,33},{450,45},{450,979},{450,991},{451,33},{451,45},{451,979},{451,991},{452,32},{452,44},{452,980},
	{452,992},{453,32},{453,44},{453,980},{453,992},{454,31},{454,43},{454,981},{454,993},{455,31},{455,43},{455,981},{455,993},{456,30},
	{456,42},{456,982},{456,994},{457,30},{457,42},{457,982},{457,994},{458,29},{458,41},{458,983},{458,995},{459,29},{459,41},{459,983},
	{459,995},{460,28},{460,40},{460,984},{460,996},{461,28},{461,40},{461,984},{461,996},{462,27},{462,40},{462,984},{462,997},{463,27},
	{463,39},{463,985},{463,997},{464,27},{464,39},{464,985},{464,997},{465,26},{465,38},{465,986},{465,998},{466,26},{466,38},{466,986},
	{466,998},{467,25},{467,37},{467,987},{467,999},{468,25},{468,37},{468,987},{468,999},{469,24},{469,36},{469,988},{469,1000},{470,24},
	{470,36},{470,988},{470,1000},{471,23},{471,35},{471,989},{471,1001},{472,23},{472,35},{472,989},{472,1001},{473,22},{473,34},{473,990},
	{473,1002},{474,22},{474,34},{474,990},{474,1002},{475,21},{475,33},{475,991},{475,1003},{476,21},{476,33},{476,991},{476,1003},{477,20},
	{477,32},{477,992},{477,1004},{478,20},{478,32},{478,992},{478,1004},{479,19},{479,32},{479,992},{479,1005},{480,19},{480,31},{480,993},
	{480,1005},{481,19},{481,31},{481,993},{481,1005},{482,18},{482,30},{482,994},{482,1006},{483,18},{483,30},{483,994},{483,1006},{484,17},
	{484,29},{484,995},{484,1007},{485,17},{485,29},{485,995},{485,1007},{486,16},{486,28},{486,996},{486,1008},{487,16},{487,28},{487,996},
	{487,1008},{488,15},{488,27},{488,997},{488,1009},{489,15},{489,27},{489,997},{489,1009},{490,14},{490,26},{490,998},{490,1010},{491,14},
	{491,26},{491,998},{491,1010},{492,13},{492,25},{492,999},{492,1011},{493,13},{493,25},{493,999},{493,1011},{494,12},{494,24},{494,1000},
	{494,1012},{495,12},{495,24},{495,1000},{495,1012},{496,11},{496,24},{496,1000},{496,1013},{497,11},{497,23},{497,1001},{497,1013},{498,11},
	{498,23},{498,1001},{498,1013},{499,10},{499,22},{499,1002},{499,1014},{500,10},{500,22},{500,1002},{500,1014},{501,9},{501,21},{501,1003},
	{501,1015},{502,9},{502,21},{502,1003},{502,1015},{503,8},{503,20},{503,1004},{503,1016},{504,8},{504,20},{504,1004},{504,1016},{505,7},
	{505,19},{505,1005},{505,1017},{506,7},{506,19},{506,1005},{506,1017},{507,6},{507,18},{507,1006},{507,1018},{508,6},{508,18},{508,1006},
	{508,1018},{509,5},{509,17},{509,1007},{509,1019},{510,5},{510,17},{510,1007},{510,1019},{511,4},{511,16},{511,1008},{511,1020},{512,4},
	{512,16},{512,1008},{512,1020},{513,3},{513,16},{513,1008},{513,1021},{514,3},{514,15},{514,1009},{514,1021},{515,3},{515,15},{515,1009},
	{515,1021},{516,2},{516,14},{516,1010},{516,1022},{517,2},{517,14},{517,1010},{517,1022}
}; 
#else
	int line_data[][2] = {
	{127,163},{127,637},{128,163},{128,637},{129,162},{129,638},{130,162},{130,638},{131,161},{131,639},{132,161},{132,639},{133,160},{133,640},
	{134,160},{134,640},{135,159},{135,169},{135,631},{135,641},{136,159},{136,169},{136,631},{136,641},{137,159},{137,168},{137,632},{137,641},
	{138,158},{138,168},{138,632},{138,642},{139,158},{139,167},{139,633},{139,642},{140,157},{140,167},{140,633},{140,643},{141,157},{141,166},
	{141,634},{141,643},{142,156},{142,166},{142,634},{142,644},{143,156},{143,166},{143,635},{143,644},{144,155},{144,165},{144,635},{144,645},
	{145,155},{145,164},{145,636},{145,645},{146,154},{146,164},{146,636},{146,646},{147,154},{147,163},{147,637},{147,646},{148,153},{148,163},
	{148,637},{148,647},{149,153},{149,162},{149,638},{149,647},{150,152},{150,162},{150,638},{150,648},{151,152},{151,161},{151,639},{151,648},
	{152,151},{152,161},{152,639},{152,649},{153,151},{153,161},{153,639},{153,649},{154,151},{154,160},{154,640},{154,650},{155,150},{155,160},
	{155,640},{155,650},{156,150},{156,159},{156,641},{156,650},{157,149},{157,159},{157,641},{157,651},{158,149},{158,158},{158,642},{158,651},
	{159,148},{159,652},{160,148},{160,652},{161,147},{161,653},{162,147},{162,653},{163,146},{163,654},{164,146},{164,654},{165,145},{165,655},
	{166,145},{166,655},{167,144},{167,656},{168,144},{168,154},{168,646},{168,656},{169,143},{169,153},{169,647},{169,657},{170,143},{170,153},
	{170,647},{170,657},{171,142},{171,152},{171,648},{171,658},{172,142},{172,152},{172,648},{172,658},{173,142},{173,151},{173,649},{173,658},
	{174,141},{174,151},{174,649},{174,659},{175,141},{175,150},{175,650},{175,659},{176,140},{176,150},{176,650},{176,660},{177,140},{177,149},
	{177,651},{177,660},{178,139},{178,149},{178,651},{178,661},{179,139},{179,148},{179,652},{179,661},{180,138},{180,148},{180,652},{180,662},
	{181,138},{181,147},{181,653},{181,662},{182,137},{182,147},{182,653},{182,663},{183,137},{183,146},{183,654},{183,663},{184,136},{184,146},
	{184,654},{184,664},{185,136},{185,145},{185,655},{185,664},{186,135},{186,145},{186,655},{186,665},{187,135},{187,145},{187,655},{187,665},
	{188,134},{188,144},{188,656},{188,666},{189,134},{189,144},{189,656},{189,666},{190,134},{190,143},{190,657},{190,666},{191,133},{191,143},
	{191,657},{191,667},{192,133},{192,142},{192,658},{192,667},{193,132},{193,142},{193,658},{193,668},{194,132},{194,141},{194,659},{194,668},
	{195,131},{195,141},{195,659},{195,669},{196,131},{196,140},{196,660},{196,669},{197,130},{197,140},{197,660},{197,670},{198,130},{198,139},
	{198,661},{198,670},{199,129},{199,139},{199,661},{199,671},{200,129},{200,138},{200,662},{200,671},{201,128},{201,138},{201,662},{201,672},
	{202,128},{202,137},{202,663},{202,672},{203,127},{203,137},{203,663},{203,673},{204,127},{204,137},{204,663},{204,673},{205,126},{205,674},
	{206,126},{206,674},{207,126},{207,674},{208,125},{208,675},{209,125},{209,675},{210,124},{210,676},{211,124},{211,676},{212,123},{212,677},
	{213,123},{213,677},{214,122},{214,132},{214,668},{214,678},{215,122},{215,132},{215,668},{215,678},{216,121},{216,131},{216,669},{216,679},
	{217,121},{217,131},{217,669},{217,679},{218,120},{218,130},{218,670},{218,680},{219,120},{219,130},{219,670},{219,680},{220,119},{220,129},
	{220,671},{220,681},{221,119},{221,129},{221,671},{221,681},{222,118},{222,128},{222,672},{222,682},{223,118},{223,128},{223,672},{223,682},
	{224,118},{224,127},{224,673},{224,682},{225,117},{225,127},{225,673},{225,683},{226,117},{226,126},{226,674},{226,683},{227,116},{227,126},
	{227,674},{227,684},{228,116},{228,125},{228,675},{228,684},{229,115},{229,125},{229,675},{229,685},{230,115},{230,124},{230,676},{230,685},
	{231,114},{231,124},{231,676},{231,686},{232,114},{232,123},{232,677},{232,686},{233,113},{233,123},{233,677},{233,687},{234,113},{234,122},
	{234,678},{234,687},{235,112},{235,122},{235,678},{235,688},{236,112},{236,121},{236,679},{236,688},{237,111},{237,121},{237,679},{237,689},
	{238,111},{238,121},{238,679},{238,689},{239,110},{239,120},{239,680},{239,690},{240,110},{240,120},{240,680},{240,690},{241,110},{241,119},
	{241,681},{241,690},{242,109},{242,119},{242,681},{242,691},{243,109},{243,118},{243,682},{243,691},{244,108},{244,118},{244,682},{244,692},
	{245,108},{245,117},{245,683},{245,692},{246,107},{246,117},{246,683},{246,693},{247,107},{247,116},{247,684},{247,693},{248,106},{248,116},
	{248,684},{248,694},{249,106},{249,115},{249,685},{249,694},{250,105},{250,115},{250,685},{250,695},{251,105},{251,114},{251,686},{251,695},
	{252,104},{252,114},{252,686},{252,696},{253,104},{253,113},{253,687},{253,696},{254,103},{254,113},{254,687},{254,697},{255,103},{255,113},
	{255,687},{255,697},{256,102},{256,112},{256,688},{256,698},{257,102},{257,112},{257,688},{257,698},{258,102},{258,111},{258,689},{258,698},
	{259,101},{259,111},{259,689},{259,699},{260,101},{260,110},{260,690},{260,699},{261,100},{261,110},{261,690},{261,700},{262,100},{262,109},
	{262,691},{262,700},{263,99},{263,701},{264,99},{264,701},{265,98},{265,702},{266,98},{266,702},{267,97},{267,703},{268,97},{268,703},
	{269,96},{269,704},{270,96},{270,704},{271,95},{271,705},{272,95},{272,105},{272,695},{272,705},{273,94},{273,104},{273,696},{273,706},
	{274,94},{274,104},{274,696},{274,706},{275,94},{275,103},{275,697},{275,707},{276,93},{276,103},{276,697},{276,707},{277,93},{277,102},
	{277,698},{277,707},{278,92},{278,102},{278,698},{278,708},{279,92},{279,101},{279,699},{279,708},{280,91},{280,101},{280,699},{280,709},
	{281,91},{281,100},{281,700},{281,709},{282,90},{282,100},{282,700},{282,710},{283,90},{283,99},{283,701},{283,710},{284,89},{284,99},
	{284,701},{284,711},{285,89},{285,98},{285,702},{285,711},{286,88},{286,98},{286,702},{286,712},{287,88},{287,97},{287,703},{287,712},
	{288,87},{288,97},{288,703},{288,713},{289,87},{289,97},{289,703},{289,713},{290,86},{290,96},{290,704},{290,714},{291,86},{291,96},
	{291,704},{291,714},{292,86},{292,95},{292,705},{292,714},{293,85},{293,95},{293,705},{293,715},{294,85},{294,94},{294,706},{294,715},
	{295,84},{295,94},{295,706},{295,716},{296,84},{296,93},{296,707},{296,716},{297,83},{297,93},{297,707},{297,717},{298,83},{298,92},
	{298,708},{298,717},{299,82},{299,92},{299,708},{299,718},{300,82},{300,91},{300,709},{300,718},{301,81},{301,91},{301,709},{301,719},
	{302,81},{302,90},{302,710},{302,719},{303,80},{303,90},{303,710},{303,720},{304,80},{304,89},{304,711},{304,720},{305,79},{305,89},
	{305,711},{305,721},{306,79},{306,89},{306,711},{306,721},{307,78},{307,88},{307,712},{307,722},{308,78},{308,88},{308,712},{308,722},
	{309,78},{309,87},{309,713},{309,722},{310,77},{310,87},{310,713},{310,723},{311,77},{311,86},{311,714},{311,723},{312,76},{312,86},
	{312,714},{312,724},{313,76},{313,85},{313,715},{313,724},{314,75},{314,85},{314,715},{314,725},{315,75},{315,84},{315,716},{315,725},
	{316,74},{316,84},{316,716},{316,726},{317,74},{317,83},{317,717},{317,726},{318,73},{318,83},{318,717},{318,727},{319,73},{319,82},
	{319,718},{319,727},{320,72},{320,82},{320,718},{320,728},{321,72},{321,81},{321,719},{321,728},{322,71},{322,81},{322,719},{322,729},
	{323,71},{323,81},{323,719},{323,729},{324,70},{324,80},{324,720},{324,730},{325,70},{325,80},{325,720},{325,730},{326,70},{326,79},
	{326,721},{326,730},{327,69},{327,79},{327,721},{327,731},{328,69},{328,78},{328,722},{328,731},{329,68},{329,78},{329,722},{329,732},
	{330,68},{330,77},{330,723},{330,732},{331,67},{331,77},{331,723},{331,733},{332,67},{332,76},{332,724},{332,733},{333,66},{333,76},
	{333,724},{333,734},{334,66},{334,75},{334,725},{334,734},{335,65},{335,75},{335,725},{335,735},{336,65},{336,735},{337,64},{337,736},
	{338,64},{338,736},{339,63},{339,737},{340,63},{340,737},{341,62},{341,738},{342,62},{342,738},{343,62},{343,738},{344,61},{344,739},
	{345,61},{345,71},{345,729},{345,739},{346,60},{346,70},{346,730},{346,740},{347,60},{347,70},{347,730},{347,740},{348,59},{348,69},
	{348,731},{348,741},{349,59},{349,69},{349,731},{349,741},{350,58},{350,68},{350,732},{350,742},{351,58},{351,68},{351,732},{351,742},
	{352,57},{352,67},{352,733},{352,743},{353,57},{353,67},{353,733},{353,743},{354,56},{354,66},{354,734},{354,744},{355,56},{355,65},
	{355,735},{355,744},{356,55},{356,65},{356,735},{356,745},{357,55},{357,65},{357,735},{357,745},{358,54},{358,64},{358,736},{358,746},
	{359,54},{359,64},{359,736},{359,746},{360,54},{360,63},{360,737},{360,746},{361,53},{361,63},{361,737},{361,747},{362,53},{362,62},
	{362,738},{362,747},{363,52},{363,62},{363,738},{363,748},{364,52},{364,61},{364,739},{364,748},{365,51},{365,61},{365,739},{365,749},
	{366,51},{366,60},{366,740},{366,749},{367,50},{367,60},{367,740},{367,750},{368,50},{368,59},{368,741},{368,750},{369,49},{369,59},
	{369,741},{369,751},{370,49},{370,58},{370,742},{370,751},{371,48},{371,58},{371,742},{371,752},{372,48},{372,57},{372,743},{372,752},
	{373,47},{373,57},{373,743},{373,753},{374,47},{374,57},{374,743},{374,753},{375,46},{375,56},{375,744},{375,754},{376,46},{376,56},
	{376,744},{376,754},{377,46},{377,55},{377,745},{377,754},{378,45},{378,55},{378,745},{378,755},{379,45},{379,54},{379,746},{379,755},
	{380,44},{380,54},{380,746},{380,756},{381,44},{381,53},{381,747},{381,756},{382,43},{382,53},{382,747},{382,757},{383,43},{383,52},
	{383,748},{383,757},{384,42},{384,52},{384,748},{384,758},{385,42},{385,51},{385,749},{385,758},{386,41},{386,51},{386,749},{386,759},
	{387,41},{387,50},{387,750},{387,759},{388,40},{388,50},{388,750},{388,760},{389,40},{389,49},{389,751},{389,760},{390,39},{390,49},
	{390,751},{390,761},{391,39},{391,49},{391,751},{391,761},{392,38},{392,48},{392,752},{392,762},{393,38},{393,48},{393,752},{393,762},
	{394,38},{394,47},{394,753},{394,762},{395,37},{395,47},{395,753},{395,763},{396,37},{396,46},{396,754},{396,763},{397,36},{397,46},
	{397,754},{397,764},{398,36},{398,45},{398,755},{398,764},{399,35},{399,45},{399,755},{399,765},{400,35},{400,44},{400,756},{400,765},
	{401,34},{401,44},{401,756},{401,766},{402,34},{402,43},{402,757},{402,766},{403,33},{403,43},{403,757},{403,767},{404,33},{404,42},
	{404,758},{404,767},{405,32},{405,42},{405,758},{405,768},{406,32},{406,41},{406,759},{406,768},{407,31},{407,41},{407,759},{407,769},
	{408,31},{408,41},{408,759},{408,769},{409,30},{409,40},{409,760},{409,770},{410,30},{410,40},{410,760},{410,770},{411,30},{411,39},
	{411,761},{411,770},{412,29},{412,39},{412,761},{412,771},{413,29},{413,38},{413,762},{413,771},{414,28},{414,38},{414,762},{414,772},
	{415,28},{415,37},{415,763},{415,772},{416,27},{416,37},{416,763},{416,773},{417,27},{417,36},{417,764},{417,773},{418,26},{418,36},
	{418,764},{418,774},{419,26},{419,35},{419,765},{419,774},{420,25},{420,35},{420,765},{420,775},{421,25},{421,34},{421,766},{421,775},
	{422,24},{422,34},{422,766},{422,776},{423,24},{423,33},{423,767},{423,776},{424,23},{424,33},{424,767},{424,777},{425,23},{425,33},
	{425,767},{425,777},{426,22},{426,32},{426,768},{426,778},{427,22},{427,32},{427,768},{427,778},{428,22},{428,31},{428,769},{428,778},
	{429,21},{429,31},{429,769},{429,779},{430,21},{430,30},{430,770},{430,779},{431,20},{431,30},{431,770},{431,780},{432,20},{432,29},
	{432,771},{432,780},{433,19},{433,29},{433,771},{433,781},{434,19},{434,28},{434,772},{434,781},{435,18},{435,28},{435,772},{435,782},
	{436,18},{436,27},{436,773},{436,782},{437,17},{437,27},{437,773},{437,783},{438,17},{438,26},{438,774},{438,783},{439,16},{439,26},
	{439,774},{439,784},{440,16},{440,25},{440,775},{440,784},{441,15},{441,25},{441,775},{441,785},{442,15},{442,25},{442,775},{442,785},
	{443,14},{443,24},{443,776},{443,786},{444,14},{444,24},{444,776},{444,786},{445,14},{445,23},{445,777},{445,786},{446,13},{446,23},
	{446,777},{446,787},{447,13},{447,22},{447,778},{447,787},{448,12},{448,22},{448,778},{448,788},{449,12},{449,21},{449,779},{449,788},
	{450,11},{450,21},{450,779},{450,789},{451,11},{451,20},{451,780},{451,789},{452,10},{452,20},{452,780},{452,790},{453,10},{453,19},
	{453,781},{453,790},{454,9},{454,19},{454,781},{454,791},{455,9},{455,18},{455,782},{455,791},{456,8},{456,18},{456,782},{456,792},
	{457,8},{457,17},{457,783},{457,792},{458,7},{458,17},{458,783},{458,793},{459,7},{459,17},{459,783},{459,793},{460,6},{460,16},
	{460,784},{460,794},{461,6},{461,16},{461,784},{461,794},{462,6},{462,15},{462,785},{462,794},{463,5},{463,15},{463,785},{463,795},
	{464,5},{464,14},{464,786},{464,795},{465,4},{465,14},{465,786},{465,799}
}; 
#endif
// tnn e

/*------------------------------------------------------------------------------
 * BUS Configure
 */
#if (CFG_BUS_RECONFIG_ENB == 1)
#include <mach/s5p4418_bus.h>

const u16 g_DrexQoS[2] = {
	0x100,		// S0
	0xFFF		// S1, Default value
};

const u8 g_TopBusSI[8] = {
	TOPBUS_SI_SLOT_DMAC0,
	TOPBUS_SI_SLOT_USBOTG,
	TOPBUS_SI_SLOT_USBHOST0,
	TOPBUS_SI_SLOT_DMAC1,
	TOPBUS_SI_SLOT_SDMMC,
	TOPBUS_SI_SLOT_USBOTG,
	TOPBUS_SI_SLOT_USBHOST1,
	TOPBUS_SI_SLOT_USBOTG
};

const u8 g_BottomBusSI[8] = {
	BOTBUS_SI_SLOT_1ST_ARM,
	BOTBUS_SI_SLOT_MALI,
	BOTBUS_SI_SLOT_DEINTERLACE,
	BOTBUS_SI_SLOT_1ST_CODA,
	BOTBUS_SI_SLOT_2ND_ARM,
	BOTBUS_SI_SLOT_SCALER,
	BOTBUS_SI_SLOT_TOP,
	BOTBUS_SI_SLOT_2ND_CODA
};

const u8 g_BottomQoSSI[2] = {
	1,	// Tidemark
	(1<<BOTBUS_SI_SLOT_1ST_ARM) |	// Control
	(1<<BOTBUS_SI_SLOT_2ND_ARM) |
	(1<<BOTBUS_SI_SLOT_MALI) |
	(1<<BOTBUS_SI_SLOT_TOP) |
	(1<<BOTBUS_SI_SLOT_DEINTERLACE) |
	(1<<BOTBUS_SI_SLOT_1ST_CODA)
};

const u8 g_DispBusSI[3] = {
	DISBUS_SI_SLOT_1ST_DISPLAY,
	DISBUS_SI_SLOT_2ND_DISPLAY,
	DISBUS_SI_SLOT_2ND_DISPLAY  //DISBUS_SI_SLOT_GMAC
};
#endif	/* #if (CFG_BUS_RECONFIG_ENB == 1) */

/*------------------------------------------------------------------------------
 * CPU Frequence
 */
#if defined(CONFIG_ARM_NXP_CPUFREQ)

struct nxp_cpufreq_plat_data dfs_plat_data = {
	.pll_dev	   	= CONFIG_NXP_CPUFREQ_PLLDEV,
	.supply_name	= "vdd_arm_1.3V",	//refer to CONFIG_REGULATOR_NXE2000
	.max_cpufreq	= 1400*1000,
	.max_retention  =   20*1000,
	.rest_cpufreq   =  400*1000,
	.rest_retention =    1*1000,
};

static struct platform_device dfs_plat_device = {
	.name			= DEV_NAME_CPUFREQ,
	.dev			= {
		.platform_data	= &dfs_plat_data,
	}
};
#endif

/*------------------------------------------------------------------------------
 * Network DM9000
 */
#if defined(CONFIG_DM9000) || defined(CONFIG_DM9000_MODULE)
#include <linux/dm9000.h>

static struct resource dm9000_resource[] = {
	[0] = {
		.start	= CFG_ETHER_EXT_PHY_BASEADDR,
		.end	= CFG_ETHER_EXT_PHY_BASEADDR + 1,		// 1 (8/16 BIT)
		.flags	= IORESOURCE_MEM
	},
	[1] = {
		.start	= CFG_ETHER_EXT_PHY_BASEADDR + 4,		// + 4 (8/16 BIT)
		.end	= CFG_ETHER_EXT_PHY_BASEADDR + 5,		// + 5 (8/16 BIT)
		.flags	= IORESOURCE_MEM
	},
	[2] = {
		.start	= CFG_ETHER_EXT_IRQ_NUM,
		.end	= CFG_ETHER_EXT_IRQ_NUM,
		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
	}
};

static struct dm9000_plat_data eth_plat_data = {
	.flags		= DM9000_PLATF_8BITONLY,	// DM9000_PLATF_16BITONLY
};

static struct platform_device dm9000_plat_device = {
	.name			= "dm9000",
	.id				= 0,
	.num_resources	= ARRAY_SIZE(dm9000_resource),
	.resource		= dm9000_resource,
	.dev			= {
		.platform_data	= &eth_plat_data,
	}
};
#endif	/* CONFIG_DM9000 || CONFIG_DM9000_MODULE */

/*------------------------------------------------------------------------------
 * DISPLAY (LVDS) / FB
 */
#if defined (CONFIG_FB_NXP)
#if defined (CONFIG_FB0_NXP)
static struct nxp_fb_plat_data fb0_plat_data = {
	.module			= CONFIG_FB0_NXP_DISPOUT,
	.layer			= CFG_DISP_PRI_SCREEN_LAYER,
	.format			= CFG_DISP_PRI_SCREEN_RGB_FORMAT,
	.bgcolor		= CFG_DISP_PRI_BACK_GROUND_COLOR,
	.bitperpixel	= CFG_DISP_PRI_SCREEN_PIXEL_BYTE * 8,
	.x_resol		= CFG_DISP_PRI_RESOL_WIDTH,
	.y_resol		= CFG_DISP_PRI_RESOL_HEIGHT,
	#ifdef CONFIG_ANDROID
	.buffers		= 3,
	.skip_pan_vsync	= 1,
	#else
	.buffers		= 2,
	#endif
	.lcd_with_mm	= CFG_DISP_PRI_LCD_WIDTH_MM,	/* 152.4 */
	.lcd_height_mm	= CFG_DISP_PRI_LCD_HEIGHT_MM,	/* 91.44 */
};

static struct platform_device fb0_device = {
	.name	= DEV_NAME_FB,
	.id		= 0,	/* FB device node num */
	.dev    = {
		.coherent_dma_mask 	= 0xffffffffUL,	/* for DMA allocate */
		.platform_data		= &fb0_plat_data
	},
};
#endif

static struct platform_device *fb_devices[] = {
	#if defined (CONFIG_FB0_NXP)
	&fb0_device,
	#endif
};
#endif /* CONFIG_FB_NXP */

/*------------------------------------------------------------------------------
 * backlight : generic pwm device
 */
#if defined(CONFIG_BACKLIGHT_PWM)
#include <linux/pwm_backlight.h>

static struct platform_pwm_backlight_data bl_plat_data = {
	.pwm_id			= CFG_LCD_PRI_PWM_CH,
	.max_brightness = 255,//	/* 255 is 100%, set over 100% */
	.dft_brightness = 100,//	/* 99% */
	.pwm_period_ns	= 1000000000/CFG_LCD_PRI_PWM_FREQ,
};

static struct platform_device bl_plat_device = {
	.name	= "pwm-backlight",
	.id		= -1,
	.dev	= {
		.platform_data	= &bl_plat_data,
	},
};

#endif

/*------------------------------------------------------------------------------
 * NAND device
 */
#if defined(CONFIG_MTD_NAND_NXP)
#include <linux/mtd/partitions.h>
#include <asm-generic/sizes.h>

static struct mtd_partition nxp_nand_parts[] = {
#if 0
	{
		.name           = "root",
		.offset         =   0 * SZ_1M,
	},
#else
	{
		.name		= "system",
		.offset		=  64 * SZ_1M,
		.size		= 512 * SZ_1M,
	}, {
		.name		= "cache",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 256 * SZ_1M,
	}, {
		.name		= "userdata",
		.offset		= MTDPART_OFS_APPEND,
		.size		= MTDPART_SIZ_FULL,
	}
#endif
};

static struct nxp_nand_plat_data nand_plat_data = {
	.parts		= nxp_nand_parts,
	.nr_parts	= ARRAY_SIZE(nxp_nand_parts),
	.chip_delay = 10,
};

static struct platform_device nand_plat_device = {
	.name	= DEV_NAME_NAND,
	.id		= -1,
	.dev	= {
		.platform_data	= &nand_plat_data,
	},
};
#endif	/* CONFIG_MTD_NAND_NXP */

#if defined(CONFIG_TOUCHSCREEN_GSLX680)
#include <linux/i2c.h>
#define	GSLX680_I2C_BUS		(1)

static struct i2c_board_info __initdata gslX680_i2c_bdi = {
	.type	= "gslX680",
	.addr	= (0x40),
    	.irq    = PB_PIO_IRQ(CFG_IO_TOUCH_PENDOWN_DETECT),
};
#endif

/*------------------------------------------------------------------------------
 * Touch platform device
 */
#if defined(CONFIG_TOUCHSCREEN_FT5X0X)
#include <linux/i2c.h>
#define	FT5X0X_I2C_BUS		(1)

struct nxp_ts_cali_plat_data ts_plat_data = {
	.touch_points	= 10,
	.x_resol	   	= CFG_DISP_PRI_RESOL_WIDTH,
	.y_resol	   	= CFG_DISP_PRI_RESOL_HEIGHT,
	.rotate			= 180, //90
};

static struct i2c_board_info __initdata ft5x0x_i2c_bdi = {
	.type	= "ft5x06_ts",
	.addr	= (0x70>>1),
    .irq    = PB_PIO_IRQ(CFG_IO_TOUCH_PENDOWN_DETECT),
	.platform_data = &ts_plat_data,
};
#endif

/* tnn mid s*/
#if defined(CONFIG_TOUCHSCREEN_GOODIX)
#include <linux/i2c.h>
#define	GOODIX_I2C_BUS		(1)

static struct i2c_board_info __initdata goodix_i2c_bdi = {
	.type	= "Goodix-TS",
	.addr	= (0x28>>1),
    .irq    = PB_PIO_IRQ(CFG_IO_TOUCH_PENDOWN_DETECT),
};
#endif
/* tnn mid e*/

#if defined(CONFIG_TOUCHSCREEN_ATMEL_MXT)
#include <linux/i2c.h>
#include <linux/i2c/atmel_mxt_ts.h>
#define	ATMEL_I2C_BUS		(1)
#define	ATMEL_MXT_I2C_ADDR		(0x94>>1)	// 0x4A

static struct mxt_platform_data mxt_data = {
	.gpio_reset = CFG_IO_TOUCH_RESET_PIN,	
};

static struct i2c_board_info __initdata atmel_i2c_boardinfo[] = {
	{
		I2C_BOARD_INFO("atmel_mxt_ts", ATMEL_MXT_I2C_ADDR),
		.platform_data	= &mxt_data,
	}
};
#endif


/*------------------------------------------------------------------------------
 * Keypad platform device
 */
#if defined(CONFIG_KEYBOARD_NXP_KEY) || defined(CONFIG_KEYBOARD_NXP_KEY_MODULE)

#include <linux/input.h>

static unsigned int  button_gpio[] = CFG_KEYPAD_KEY_BUTTON;
static unsigned int  button_code[] = CFG_KEYPAD_KEY_CODE;

struct nxp_key_plat_data key_plat_data = {
	.bt_count	= ARRAY_SIZE(button_gpio),
	.bt_io		= button_gpio,
	.bt_code	= button_code,
	.bt_repeat	= CFG_KEYPAD_REPEAT,
};

static struct platform_device key_plat_device = {
	.name	= DEV_NAME_KEYPAD,
	.id		= -1,
	.dev    = {
		.platform_data	= &key_plat_data
	},
};
#endif	/* CONFIG_KEYBOARD_NXP_KEY || CONFIG_KEYBOARD_NXP_KEY_MODULE */

/*------------------------------------------------------------------------------
 * ASoC Codec platform device
 */
#if defined(CONFIG_SND_SPDIF_TRANSCIEVER) || defined(CONFIG_SND_SPDIF_TRANSCIEVER_MODULE)
static struct platform_device spdif_transciever = {
	.name	= "spdif-dit",
	.id		= -1,
};

struct nxp_snd_dai_plat_data spdif_trans_dai_data = {
	.sample_rate = 48000,
	.pcm_format	 = SNDRV_PCM_FMTBIT_S16_LE,
};

static struct platform_device spdif_trans_dai = {
	.name	= "spdif-transciever",
	.id		= -1,
	.dev	= {
		.platform_data	= &spdif_trans_dai_data,
	}
};
#endif

#if defined(CONFIG_SND_CODEC_ES8316) || defined(CONFIG_SND_CODEC_ES8316_MODULE)
#include <linux/i2c.h>

#define	ES8316_I2C_BUS		(0)

/* CODEC */
static struct i2c_board_info __initdata es8316_i2c_bdi = {
	.type	= "es8316",
	.addr	= (0x22>>1),		// 0x11 (7BIT), 0x22(8BIT)
};

/* DAI */
struct nxp_snd_dai_plat_data i2s_dai_data = {
	.i2s_ch	= 0,
	.sample_rate	= 48000,
	.pcm_format = SNDRV_PCM_FMTBIT_S16_LE,
#if 1
	.hp_jack 		= {
		.support    	= 1,
		.detect_io		= PAD_GPIO_B + 27,
		.detect_level	= 1,
	},
#endif
};

static struct platform_device es8316_dai = {
	.name			= "es8316-audio",
	.id				= 0,
	.dev			= {
		.platform_data	= &i2s_dai_data,
	}
};
#endif

/* tnn mid s*/
#if defined(CONFIG_SND_CODEC_ALC5633)
#include <linux/i2c.h>

#define ALC5633_I2C_BUS          (0)

/* CODEC */
static struct i2c_board_info __initdata alc5633_i2c_bdi = {
	.type   = "alc5633",                     // compatilbe with wm8976
	.addr   = (0x38>>1),            // 0x1A (7BIT), 0x34(8BIT)
};

/* DAI */
struct nxp_snd_dai_plat_data i2s_dai_data = {
	.i2s_ch			= 0,
	.sample_rate	= 48000,
	.hp_jack		= {
		.support		= 0,
		.detect_io		= PAD_GPIO_A + 0,
		.detect_level	= 1,
	},
};

static struct platform_device alc5633_dai = {
	.name	= "alc5633-audio",
	.id		= 0,
	.dev	= {
		.platform_data  = &i2s_dai_data,
	}
};
#endif
/* tnn mid e*/
#if defined(CONFIG_SND_CODEC_ALCDUMMY)
#include <linux/i2c.h>

#define ALCDUMMY_I2C_BUS          (1)

/* CODEC */
static struct i2c_board_info __initdata alcdummy_i2c_bdi = {
	.type   = "alcdummy",                     // compatilbe with wm8976
	.addr   = (0x38>>1),            // 0x1A (7BIT), 0x34(8BIT)
};

/* DAI */
struct nxp_snd_dai_plat_data i2s_dummy_data = {
	.i2s_ch			= 1,
	.sample_rate	= 48000,
	.hp_jack		= {
		.support		= 0,
		.detect_io		= PAD_GPIO_A + 0,
		.detect_level	= 1,
	},
};

static struct platform_device alcdummy_dai = {
	.name		= "alcdummy-audio",
	.id			= 1,
	.dev		= {
		.platform_data  = &i2s_dummy_data,
	}
};
#endif


/*------------------------------------------------------------------------------
 * G-Sensor platform device
 */
#if defined(CONFIG_SENSORS_MMA865X) || defined(CONFIG_SENSORS_MMA865X_MODULE)
#include <linux/i2c.h>

#define	MMA865X_I2C_BUS		(2)

/* CODEC */
static struct i2c_board_info __initdata mma865x_i2c_bdi = {
	.type	= "mma8653",
	.addr	= 0x1D//(0x3a),
};

#endif

#if defined(CONFIG_SENSORS_STK831X) || defined(CONFIG_SENSORS_STK831X_MODULE)
#include <linux/i2c.h>

#define	STK831X_I2C_BUS		(2)

/* CODEC */
static struct i2c_board_info __initdata stk831x_i2c_bdi = {
#if   defined CONFIG_SENSORS_STK8312
	.type	= "stk8312",
	.addr	= (0x3d),
#elif defined CONFIG_SENSORS_STK8313
	.type	= "stk8313",
	.addr	= (0x22),
#endif
};

#endif

/*------------------------------------------------------------------------------
 *  * reserve mem
 *   */
#ifdef CONFIG_CMA
#include <linux/cma.h>
extern void nxp_cma_region_reserve(struct cma_region *, const char *);

#if 0
void __init nxp_reserve_mem(void)
{
    static struct cma_region regions[] = {
        {
            .name = "ion",
#ifdef CONFIG_ION_NXP_CONTIGHEAP_SIZE
            .size = CONFIG_ION_NXP_CONTIGHEAP_SIZE * SZ_1K,
#else
			.size = 0,
#endif
            {
                .alignment = PAGE_SIZE,
            }
        },
        {
            .size = 0
        }
    };

    static const char map[] __initconst =
        "ion-nxp=ion;"
        "nx_vpu=ion;";

#ifdef CONFIG_ION_NXP_CONTIGHEAP_SIZE
    printk("%s: reserve CMA: size %d\n", __func__, CONFIG_ION_NXP_CONTIGHEAP_SIZE * SZ_1K);
#endif
    nxp_cma_region_reserve(regions, map);
}
#else
void __init nxp_reserve_mem(void)
{
    static struct cma_region regions[] = {
#ifdef CONFIG_ION_NXP_RESERVEHEAP_SIZE
        {
            .name = "ion-reserve",
            .size = CONFIG_ION_NXP_RESERVEHEAP_SIZE * SZ_1K,
            {
                .alignment = PAGE_SIZE,
            }
        },
#endif
        {
            .name = "ion",
#ifdef CONFIG_ION_NXP_CONTIGHEAP_SIZE
            .size = CONFIG_ION_NXP_CONTIGHEAP_SIZE * SZ_1K,
#else
			.size = 0,
#endif
            {
                .alignment = PAGE_SIZE,
            }
        },
        {
            .size = 0
        }
    };

    static const char map[] __initconst =
        "ion-nxp/ion-reserve=ion-reserve;"
        "ion-nxp/ion-nxp=ion;"
        "nx_vpu=ion;";

#ifdef CONFIG_ION_NXP_RESERVEHEAP_SIZE
    printk("%s: reserve CMA: size %d\n", __func__, CONFIG_ION_NXP_RESERVEHEAP_SIZE * SZ_1K);
#endif

#ifdef CONFIG_ION_NXP_CONTIGHEAP_SIZE
    printk("%s: reserve CMA: size %d\n", __func__, CONFIG_ION_NXP_CONTIGHEAP_SIZE * SZ_1K);
#endif

    nxp_cma_region_reserve(regions, map);
}
#endif
#endif


/*------------------------------------------------------------------------------
 * PMIC platform device
 */
#if defined(CONFIG_REGULATOR_NXE2000)

#include <linux/i2c.h>
#include <linux/regulator/machine.h>
#include <linux/mfd/nxe2000.h>
#include <linux/gpio.h>
#include <linux/io.h>
#include <linux/regulator/fixed.h>
#include <linux/regulator/nxe2000-regulator.h>
#include <linux/power/nxe2000_battery.h>
//#include <linux/rtc/rtc-nxe2000.h>
//#include <linux/rtc.h>

#define NXE2000_I2C_BUS		(0)
#define NXE2000_I2C_ADDR	(0x64 >> 1)

/* NXE2000 IRQs */
#define NXE2000_IRQ_BASE	(IRQ_SYSTEM_END)
#define NXE2000_GPIO_BASE	(ARCH_NR_GPIOS) //PLATFORM_NXE2000_GPIO_BASE
#define NXE2000_GPIO_IRQ	(NXE2000_GPIO_BASE + 8)

//#define CONFIG_NXE2000_RTC


static struct regulator_consumer_supply nxe2000_dc1_supply_0[] = {
	REGULATOR_SUPPLY("vdd_arm_1.3V", NULL),
};
static struct regulator_consumer_supply nxe2000_dc2_supply_0[] = {
	REGULATOR_SUPPLY("vdd_core_1.2V", NULL),
};
static struct regulator_consumer_supply nxe2000_dc3_supply_0[] = {
	REGULATOR_SUPPLY("vdd_sys_3.3V", NULL),
};
static struct regulator_consumer_supply nxe2000_dc4_supply_0[] = {
	REGULATOR_SUPPLY("vdd_ddr_1.6V", NULL),
};
static struct regulator_consumer_supply nxe2000_dc5_supply_0[] = {
	REGULATOR_SUPPLY("vdd_sys_1.6V", NULL),
};

static struct regulator_consumer_supply nxe2000_ldo1_supply_0[] = {
	REGULATOR_SUPPLY("vgps_3.3V", NULL),
};
static struct regulator_consumer_supply nxe2000_ldo2_supply_0[] = {
	REGULATOR_SUPPLY("vcam1_1.8V", NULL),
};
static struct regulator_consumer_supply nxe2000_ldo3_supply_0[] = {
	REGULATOR_SUPPLY("vsys1_1.8V", NULL),
};
static struct regulator_consumer_supply nxe2000_ldo4_supply_0[] = {
	REGULATOR_SUPPLY("vsys_1.9V", NULL),
};
static struct regulator_consumer_supply nxe2000_ldo5_supply_0[] = {
	REGULATOR_SUPPLY("vcam_2.8V", NULL),
};
static struct regulator_consumer_supply nxe2000_ldo6_supply_0[] = {
	REGULATOR_SUPPLY("valive_3.3V", NULL),
};
static struct regulator_consumer_supply nxe2000_ldo7_supply_0[] = {
	REGULATOR_SUPPLY("vvid_2.8V", NULL),
};
static struct regulator_consumer_supply nxe2000_ldo8_supply_0[] = {
	REGULATOR_SUPPLY("vwifi_3.3V", NULL),
};
static struct regulator_consumer_supply nxe2000_ldo9_supply_0[] = {
	REGULATOR_SUPPLY("vhub_3.3V", NULL),
};
static struct regulator_consumer_supply nxe2000_ldo10_supply_0[] = {
	REGULATOR_SUPPLY("vhsic_1.2V", NULL),
};
static struct regulator_consumer_supply nxe2000_ldortc1_supply_0[] = {
	REGULATOR_SUPPLY("valive_1.8V", NULL),
};
static struct regulator_consumer_supply nxe2000_ldortc2_supply_0[] = {
	REGULATOR_SUPPLY("valive_1.0V", NULL),
};


#define NXE2000_PDATA_INIT(_name, _sname, _minuv, _maxuv, _always_on, _boot_on, \
	_init_uv, _init_enable, _slp_slots) \
	static struct nxe2000_regulator_platform_data pdata_##_name##_##_sname = \
	{	\
		.regulator = {	\
			.constraints = {	\
				.min_uV		= _minuv,	\
				.max_uV		= _maxuv,	\
				.valid_modes_mask	= (REGULATOR_MODE_NORMAL |	\
									REGULATOR_MODE_STANDBY),	\
				.valid_ops_mask		= (REGULATOR_CHANGE_MODE |	\
									REGULATOR_CHANGE_STATUS |	\
									REGULATOR_CHANGE_VOLTAGE),	\
				.always_on	= _always_on,	\
				.boot_on	= _boot_on,		\
				.apply_uV	= 1,			\
			},	\
			.num_consumer_supplies =		\
				ARRAY_SIZE(nxe2000_##_name##_supply_##_sname),	\
			.consumer_supplies	= nxe2000_##_name##_supply_##_sname, \
			.supply_regulator	= 0,	\
		},	\
		.init_uV		= _init_uv,		\
		.init_enable	= _init_enable,	\
		.sleep_slots	= _slp_slots,	\
	}
/* min_uV/max_uV : Please set the appropriate value for the devices that the power supplied within a*/
/*                 range from min to max voltage according to NXE2000 specification. */
NXE2000_PDATA_INIT(dc1,      0,	 950000, 2000000, 1, 1, 1300000, 1,  4);	/* 1.2V ARM */
NXE2000_PDATA_INIT(dc2,      0,	1000000, 2000000, 1, 1, 1200000, 1,  4);	/* 1.1V CORE */
NXE2000_PDATA_INIT(dc3,      0,	1000000, 3500000, 1, 1, 3300000, 1,  0);	/* 3.3V SYS */
NXE2000_PDATA_INIT(dc4,      0,	1000000, 2000000, 1, 1, 1500000, 1, -1);	/* 1.5V DDR */
NXE2000_PDATA_INIT(dc5,      0,	1000000, 2000000, 1, 1, 1500000, 1,  4);	/* 1.5V SYS */

NXE2000_PDATA_INIT(ldo1,     0,	1000000, 3500000, 1, 0, 3300000, 1,  0);	/* 3.3V GPS */
NXE2000_PDATA_INIT(ldo2,     0,	1000000, 3500000, 0, 0, 1800000, 0,  0);	/* 1.8V CAM1 */
NXE2000_PDATA_INIT(ldo3,     0,	1000000, 3500000, 1, 0, 1900000, 1,  2);	/* 1.8V SYS1 */
NXE2000_PDATA_INIT(ldo4,     0,	1000000, 3500000, 1, 0, 1900000, 1,  2);	/* 1.9V SYS */
NXE2000_PDATA_INIT(ldo5,     0,	1000000, 3500000, 0, 0, 2800000, 0,  0);	/* 2.8V VCAM */
NXE2000_PDATA_INIT(ldo6,     0,	1000000, 3500000, 1, 0, 3300000, 1, -1);	/* 3.3V ALIVE */
NXE2000_PDATA_INIT(ldo7,     0,	1000000, 3500000, 1, 0, 2800000, 1,  1);	/* 2.8V VID */
#if defined(CONFIG_RFKILL_NXP)
NXE2000_PDATA_INIT(ldo8,     0, 1000000, 3500000, 0, 0, 3300000, 0,  0);	/* 3.3V WIFI */
#else
NXE2000_PDATA_INIT(ldo8,     0,	1000000, 3500000, 0, 0, 3300000, 1,  0);	/* 3.3V WIFI */
#endif
NXE2000_PDATA_INIT(ldo9,     0,	1000000, 3500000, 1, 0, 3300000, 1,  0);	/* 3.3V HUB */
NXE2000_PDATA_INIT(ldo10,    0,	1000000, 3500000, 1, 0, 1200000, 0,  0);	/* 1.2V HSIC */
NXE2000_PDATA_INIT(ldortc1,  0,	1700000, 3500000, 1, 0, 1800000, 1, -1);	/* 1.8V ALIVE */
NXE2000_PDATA_INIT(ldortc2,  0,	1000000, 3500000, 1, 0, 1000000, 1, -1);	/* 1.0V ALIVE */


/*-------- if nxe2000 RTC exists -----------*/
#ifdef CONFIG_NXE2000_RTC
static struct nxe2000_rtc_platform_data rtc_data = {
	.irq	= NXE2000_IRQ_BASE,
	.time	= {
		.tm_year	= 1970,
		.tm_mon		= 0,
		.tm_mday	= 1,
		.tm_hour	= 0,
		.tm_min		= 0,
		.tm_sec		= 0,
	},
};

#define NXE2000_RTC_REG	\
{	\
	.id		= 0,	\
	.name	= "rtc_nxe2000",	\
	.platform_data	= &rtc_data,	\
}
#endif
/*-------- if Nexell RTC exists -----------*/

#define NXE2000_REG(_id, _name, _sname)	\
{	\
	.id		= NXE2000_ID_##_id,	\
	.name	= "nxe2000-regulator",	\
	.platform_data	= &pdata_##_name##_##_sname,	\
}

#define NXE2000_BATTERY_REG	\
{	\
    .id		= -1,	\
    .name	= "nxe2000-battery",	\
    .platform_data	= &nxe2000_battery_data,	\
}

//==========================================
//NXE2000 Power_Key device data
//==========================================
static struct nxe2000_pwrkey_platform_data nxe2000_pwrkey_data = {
	.irq 		= NXE2000_IRQ_BASE,
	.delay_ms 	= 20,
};
#define NXE2000_PWRKEY_REG		\
{	\
	.id 	= -1,	\
	.name 	= "nxe2000-pwrkey",	\
	.platform_data 	= &nxe2000_pwrkey_data,	\
}


static struct nxe2000_battery_platform_data nxe2000_battery_data = {
	.irq 				= NXE2000_IRQ_BASE,

	.input_power_type	= INPUT_POWER_TYPE_ADP_UBC,

	.gpio_otg_usbid		= CFG_GPIO_OTG_USBID_DET,
	.gpio_otg_vbus		= CFG_GPIO_OTG_VBUS_DET,
	.gpio_pmic_vbus		= CFG_GPIO_PMIC_VUSB_DET,
	.gpio_pmic_lowbat	= CFG_GPIO_PMIC_LOWBAT_DET,

	.low_vbat_vol_mv	= 3600,
	.low_vsys_vol_mv	= 3600,
	.bat_impe			= 1891,	//1500,
	.slp_ibat			= 10,	//3600,
	.multiple			= 100,	//100%
	.monitor_time		= 60,

	/* some parameter is depend of battery type */
	.type[0] = {
		.ch_vfchg		= 0x03,	/* VFCHG	= 0 - 4 (4.05v, 4.10v, 4.15v, 4.20v, 4.35v) */
		.ch_vrchg		= 0x03,	/* VRCHG	= 0 - 4 (3.85v, 3.90v, 3.95v, 4.00v, 4.10v) */
		.ch_vbatovset	= 0xFF,	/* VBATOVSET	= 0 or 1 (0 : 4.38v(up)/3.95v(down) 1: 4.53v(up)/4.10v(down)) */
		.ch_ichg 		= 0x07,	/* ICHG		= 0 - 0x1D (100mA - 3000mA) */
		.ch_ichg_slp	= 0x0E,	/* SLEEP  ICHG	= 0 - 0x1D (100mA - 3000mA) */
		.ch_ilim_adp 	= 0x18,	/* ILIM_ADP	= 0 - 0x1D (100mA - 3000mA) */
		.ch_ilim_usb 	= 0x04,	/* ILIM_USB	= 0 - 0x1D (100mA - 3000mA) */
		.ch_icchg		= 0x00,	/* ICCHG	= 0 - 3 (50mA 100mA 150mA 200mA) */
		.fg_target_vsys	= 3250,	/* This value is the target one to DSOC=0% */
		.fg_target_ibat	= 1000,	/* This value is the target one to DSOC=0% */
		.fg_poff_vbat	= 3350,	/* setting value of 0 per Vbat */
		.jt_en			= 0,	/* JEITA Enable	  = 0 or 1 (1:enable, 0:disable) */
		.jt_hw_sw		= 1,	/* JEITA HW or SW = 0 or 1 (1:HardWare, 0:SoftWare) */
		.jt_temp_h		= 50,	/* degree C */
		.jt_temp_l		= 12,	/* degree C */
		.jt_vfchg_h 	= 0x03,	/* VFCHG High  	= 0 - 4 (4.05v, 4.10v, 4.15v, 4.20v, 4.35v) */
		.jt_vfchg_l 	= 0,	/* VFCHG Low  	= 0 - 4 (4.05v, 4.10v, 4.15v, 4.20v, 4.35v) */
		.jt_ichg_h		= 0x07,	/* ICHG High  	= 0 - 0x1D (100mA - 3000mA) */
		.jt_ichg_l		= 0x04,	/* ICHG Low   	= 0 - 0x1D (100mA - 3000mA) */
	},
	/*
	.type[1] = {
		.ch_vfchg		= 0x0,
		.ch_vrchg		= 0x0,
		.ch_vbatovset	= 0x0,
		.ch_ichg		= 0x0,
		.ch_ilim_adp	= 0x0,
		.ch_ilim_usb	= 0x0,
		.ch_icchg		= 0x00,
		.fg_target_vsys	= 3300,//3000,
		.fg_target_ibat	= 1000,//1000,
		.jt_en			= 0,
		.jt_hw_sw		= 1,
		.jt_temp_h		= 40,
		.jt_temp_l		= 10,
		.jt_vfchg_h		= 0x0,
		.jt_vfchg_l		= 0,
		.jt_ichg_h		= 0x01,
		.jt_ichg_l		= 0x01,
	},
	*/

/*  JEITA Parameter
*
*          VCHG
*            |
* jt_vfchg_h~+~~~~~~~~~~~~~~~~~~~+
*            |                   |
* jt_vfchg_l-| - - - - - - - - - +~~~~~~~~~~+
*            |    Charge area    +          |
*  -------0--+-------------------+----------+--- Temp
*            !                   +
*          ICHG
*            |                   +
*  jt_ichg_h-+ - -+~~~~~~~~~~~~~~+~~~~~~~~~~+
*            +    |              +          |
*  jt_ichg_l-+~~~~+   Charge area           |
*            |    +              +          |
*         0--+----+--------------+----------+--- Temp
*            0   jt_temp_l      jt_temp_h   55
*/
};



#define NXE2000_DEV_REG 		\
	NXE2000_REG(DC1, dc1, 0),	\
	NXE2000_REG(DC2, dc2, 0),	\
	NXE2000_REG(DC3, dc3, 0),	\
	NXE2000_REG(DC4, dc4, 0),	\
	NXE2000_REG(DC5, dc5, 0),	\
	NXE2000_REG(LDO1, ldo1, 0),	\
	NXE2000_REG(LDO2, ldo2, 0),	\
	NXE2000_REG(LDO3, ldo3, 0),	\
	NXE2000_REG(LDO4, ldo4, 0),	\
	NXE2000_REG(LDO5, ldo5, 0),	\
	NXE2000_REG(LDO6, ldo6, 0),	\
	NXE2000_REG(LDO7, ldo7, 0),	\
	NXE2000_REG(LDO8, ldo8, 0),	\
	NXE2000_REG(LDO9, ldo9, 0),	\
	NXE2000_REG(LDO10, ldo10, 0),	\
	NXE2000_REG(LDORTC1, ldortc1, 0),	\
	NXE2000_REG(LDORTC2, ldortc2, 0)

static struct nxe2000_subdev_info nxe2000_devs_dcdc[] = {
	NXE2000_DEV_REG,
	NXE2000_BATTERY_REG,
	NXE2000_PWRKEY_REG,
#ifdef CONFIG_NXE2000_RTC
	NXE2000_RTC_REG,
#endif
};


#define NXE2000_GPIO_INIT(_init_apply, _output_mode, _output_val, _led_mode, _led_func) \
	{									\
		.output_mode_en = _output_mode,	\
		.output_val		= _output_val,	\
		.init_apply		= _init_apply,	\
		.led_mode		= _led_mode,	\
		.led_func		= _led_func,	\
	}
struct nxe2000_gpio_init_data nxe2000_gpio_data[] = {
	NXE2000_GPIO_INIT(false, false, 0, 0, 0),
	NXE2000_GPIO_INIT(false, false, 0, 0, 0),
	NXE2000_GPIO_INIT(false, false, 0, 0, 0),
	NXE2000_GPIO_INIT(false, false, 0, 0, 0),
	NXE2000_GPIO_INIT(false, false, 0, 0, 0),
};

static struct nxe2000_platform_data nxe2000_platform = {
	.num_subdevs		= ARRAY_SIZE(nxe2000_devs_dcdc),
	.subdevs			= nxe2000_devs_dcdc,
	.irq_base			= NXE2000_IRQ_BASE,
	.irq_type			= IRQ_TYPE_EDGE_FALLING,
	.gpio_base			= NXE2000_GPIO_BASE,
	.gpio_init_data		= nxe2000_gpio_data,
	.num_gpioinit_data	= ARRAY_SIZE(nxe2000_gpio_data),
	.enable_shutdown_pin	= true,
};

static struct i2c_board_info __initdata nxe2000_i2c_boardinfo[] = {
	{
		I2C_BOARD_INFO("nxe2000", NXE2000_I2C_ADDR),
		.irq			= CFG_GPIO_PMIC_INTR,
		.platform_data	= &nxe2000_platform,
	},
};
#endif  /* CONFIG_REGULATOR_NXE2000 */


/*------------------------------------------------------------------------------
 * v4l2 platform device
 */
#if defined(CONFIG_V4L2_NXP) || defined(CONFIG_V4L2_NXP_MODULE)
#include <linux/i2c.h>
#include <linux/delay.h>
#include <linux/regulator/consumer.h>
#include <mach/nxp-v4l2-platformdata.h>
#include <mach/soc.h>

static int camera_common_set_clock(ulong clk_rate)
{
    PM_DBGOUT("%s: %d\n", __func__, (int)clk_rate);
    if (clk_rate > 0)
        nxp_soc_pwm_set_frequency(1, clk_rate, 50);
    else
        nxp_soc_pwm_set_frequency(1, 0, 0);
    msleep(1);
    return 0;
}

static bool is_camera_port_configured = false;
static void camera_common_vin_setup_io(int module, bool force)
{
#if 0
    if (!force && is_camera_port_configured)
        return;
    else {
        u_int *pad;
        int i, len;
        u_int io, fn;


        /* VIP0:0 = VCLK, VID0 ~ 7 */
        const u_int port[][2] = {
#if 0
            /* VCLK, HSYNC, VSYNC */
            { PAD_GPIO_E +  4, NX_GPIO_PADFUNC_1 },
            { PAD_GPIO_E +  5, NX_GPIO_PADFUNC_1 },
            { PAD_GPIO_E +  6, NX_GPIO_PADFUNC_1 },
            /* DATA */
            { PAD_GPIO_D + 28, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_D + 29, NX_GPIO_PADFUNC_1 },
            { PAD_GPIO_D + 30, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_D + 31, NX_GPIO_PADFUNC_1 },
            { PAD_GPIO_E +  0, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_E +  1, NX_GPIO_PADFUNC_1 },
            { PAD_GPIO_E +  2, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_E +  3, NX_GPIO_PADFUNC_1 },
#endif
             /* VCLK, HSYNC, VSYNC */
            { PAD_GPIO_A + 28, NX_GPIO_PADFUNC_1 },
            { PAD_GPIO_E + 13, NX_GPIO_PADFUNC_2 },
            { PAD_GPIO_E +  7, NX_GPIO_PADFUNC_2 },

            { PAD_GPIO_A + 30, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_B +  0, NX_GPIO_PADFUNC_1 },
            { PAD_GPIO_B +  2, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_B +  4, NX_GPIO_PADFUNC_1 },
            { PAD_GPIO_B +  6, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_B +  8, NX_GPIO_PADFUNC_1 },
            { PAD_GPIO_B +  9, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_B + 10, NX_GPIO_PADFUNC_1 },
        };

        printk("%s\n", __func__);

        pad = (u_int *)port;
        len = sizeof(port)/sizeof(port[0]);

        for (i = 0; i < len; i++) {
            io = *pad++;
            fn = *pad++;
            nxp_soc_gpio_set_io_dir(io, 0);
            nxp_soc_gpio_set_io_func(io, fn);
        }

        is_camera_port_configured = true;
    }
#endif
}

static bool camera_power_enabled = false;
#if 0
static void camera_power_control(int enable)
{
    struct regulator *cam_io_28V = NULL;
    struct regulator *cam_core_18V = NULL;
    struct regulator *cam_io_33V = NULL;

    if (enable && camera_power_enabled)
        return;
    if (!enable && !camera_power_enabled)
        return;

    cam_core_18V = regulator_get(NULL, "vcam1_1.8V");
    if (IS_ERR(cam_core_18V)) {
        printk(KERN_ERR "%s: failed to regulator_get() for vcam1_1.8V", __func__);
        return;
    }

    cam_io_28V = regulator_get(NULL, "vcam_2.8V");
    if (IS_ERR(cam_io_28V)) {
        printk(KERN_ERR "%s: failed to regulator_get() for vcam_2.8V", __func__);
        return;
    }

    cam_io_33V = regulator_get(NULL, "vcam_3.3V");
    if (IS_ERR(cam_io_33V)) {
        printk(KERN_ERR "%s: failed to regulator_get() for vcam_3.3V", __func__);
        return;
    }

    printk("%s: %d\n", __func__, enable);
    if (enable) {
        regulator_enable(cam_core_18V);
        regulator_enable(cam_io_28V);
        regulator_enable(cam_io_33V);
    } else {
        regulator_disable(cam_io_33V);
        regulator_disable(cam_io_28V);
        regulator_disable(cam_core_18V);
    }

    regulator_put(cam_io_28V);
    regulator_put(cam_core_18V);
    regulator_put(cam_io_33V);

    camera_power_enabled = enable ? true : false;
}
#else
static void camera_power_control(int enable)
{
    struct regulator *cam_core_18V = NULL;

    if (enable && camera_power_enabled)
        return;
    if (!enable && !camera_power_enabled)
        return;

    cam_core_18V = regulator_get(NULL, "vcam1_1.8V");
    if (IS_ERR(cam_core_18V)) {
        printk(KERN_ERR "%s: failed to regulator_get() for vcam1_1.8V", __func__);
        return;
    }
    printk("%s: %d\n", __func__, enable);
    if (enable) {
        regulator_enable(cam_core_18V);
    } else {
        regulator_disable(cam_core_18V);
    }

    regulator_put(cam_core_18V);

    camera_power_enabled = enable ? true : false;
}
#endif

static bool is_back_camera_enabled = false;
static bool is_back_camera_power_state_changed = false;
static bool is_front_camera_enabled = false;
static bool is_front_camera_power_state_changed = false;

static int front_camera_power_enable(bool on);
static int back_camera_power_enable(bool on)
{

#if 0
    unsigned int io 			= CFG_IO_CAMERA_BACK_POWER_DOWN;
    unsigned int reset_io		= CFG_IO_CAMERA_BACK_RESET;
    unsigned int power_mux_io	= ((PAD_GPIO_C + 24) | PAD_FUNC_ALT0);

    PM_DBGOUT("%s: is_back_camera_enabled %d, on %d\n", __func__, is_back_camera_enabled, on);
    if (on) {
        front_camera_power_enable(0);
        if (!is_back_camera_enabled) {
            camera_power_control(1);

			/* Power MUX Enable */
			nxp_soc_gpio_set_out_value(power_mux_io, 0);
            nxp_soc_gpio_set_io_dir(power_mux_io, 1);
            nxp_soc_gpio_set_io_func(power_mux_io, nxp_soc_gpio_get_altnum(power_mux_io));
			mdelay(1);
            nxp_soc_gpio_set_out_value(power_mux_io, 1);
			mdelay(10);

            /* PDN - High Active */
            nxp_soc_gpio_set_out_value(io, 0);
            nxp_soc_gpio_set_io_dir(io, 1);
            nxp_soc_gpio_set_io_func(io, nxp_soc_gpio_get_altnum(io));
			mdelay(10);

            /* RST - Low Active */
            nxp_soc_gpio_set_out_value(reset_io, 1);
            nxp_soc_gpio_set_io_dir(reset_io, 1);
            nxp_soc_gpio_set_io_func(reset_io, nxp_soc_gpio_get_altnum(reset_io));
            nxp_soc_gpio_set_out_value(reset_io, 0);
            /* mdelay(100); */
            mdelay(1);
            nxp_soc_gpio_set_out_value(reset_io, 1);
            /* mdelay(100); */
            mdelay(10);

            is_back_camera_enabled = true;
            is_back_camera_power_state_changed = true;
        } else {
            is_back_camera_power_state_changed = false;
        }
    } else {
        if (is_back_camera_enabled) {
            nxp_soc_gpio_set_out_value(io, 1);
            nxp_soc_gpio_set_out_value(reset_io, 0);
            is_back_camera_enabled = false;
            is_back_camera_power_state_changed = true;
        } else {
            nxp_soc_gpio_set_out_value(io, 1);
            nxp_soc_gpio_set_io_dir(io, 1);
            nxp_soc_gpio_set_io_func(io, nxp_soc_gpio_get_altnum(io));
            nxp_soc_gpio_set_out_value(io, 1);
            is_back_camera_power_state_changed = false;
        }

       if (!(is_back_camera_enabled || is_front_camera_enabled)) {
            camera_power_control(0);
        }
    }
#endif

    return 0;
}

static bool back_camera_power_state_changed(void)
{
    return is_back_camera_power_state_changed;
}

static int front_camera_power_enable(bool on)
{
    unsigned int io = CFG_IO_CAMERA_FRONT_POWER_DOWN;
    unsigned int reset_io = CFG_IO_CAMERA_RESET;
    PM_DBGOUT("%s: is_front_camera_enabled %d, on %d\n", __func__, is_front_camera_enabled, on);
    if (on) {
        back_camera_power_enable(0);
        if (!is_front_camera_enabled) {
            camera_power_control(1);
            /* First RST signal to low */
            nxp_soc_gpio_set_out_value(reset_io, 1);
            nxp_soc_gpio_set_io_dir(reset_io, 1);
            nxp_soc_gpio_set_io_func(reset_io, nxp_soc_gpio_get_altnum(io));
            nxp_soc_gpio_set_out_value(reset_io, 0);
            mdelay(1);

            /* PWDN signal High to Low */
            nxp_soc_gpio_set_out_value(io, 0);
            nxp_soc_gpio_set_io_dir(io, 1);
            nxp_soc_gpio_set_io_func(io, nxp_soc_gpio_get_altnum(io));
            nxp_soc_gpio_set_out_value(io, 1);
            camera_common_set_clock(24000000);
            mdelay(10);
            /* mdelay(1); */
            nxp_soc_gpio_set_out_value(io, 0);
            /* mdelay(10); */
            mdelay(10);

            /* RST signal  to High */
            nxp_soc_gpio_set_out_value(reset_io, 1);
            /* mdelay(100); */
            mdelay(5);

            is_front_camera_enabled = true;
            is_front_camera_power_state_changed = true;
        } else {
            is_front_camera_power_state_changed = false;
        }
    } else {
        if (is_front_camera_enabled) {
            nxp_soc_gpio_set_out_value(io, 1);
            is_front_camera_enabled = false;
            is_front_camera_power_state_changed = true;
        } else {
            nxp_soc_gpio_set_out_value(io, 1);
            is_front_camera_power_state_changed = false;
        }
        if (!(is_back_camera_enabled || is_front_camera_enabled)) {
            camera_power_control(0);
        }
    }

    return 0;
}

static bool front_camera_power_state_changed(void)
{
    return is_front_camera_power_state_changed;
}

static struct i2c_board_info tw9900_i2c_boardinfo[] = {
    {
        I2C_BOARD_INFO("tw9900", 0x88>>1),
    },
};

static struct i2c_board_info front_camera_i2c_boardinfo[] = {
    {
        I2C_BOARD_INFO("SP0838", 0x18),
    },
};

static struct nxp_v4l2_i2c_board_info sensor[] = {
    {
        .board_info = &tw9900_i2c_boardinfo[0],
        .i2c_adapter_id = 0,
    },
    {
        .board_info = &front_camera_i2c_boardinfo[0],
        .i2c_adapter_id = 0,
    },
};

static int _sensor_power_enable(bool enable); 
static void _sensor_setup_io(void);

static struct nxp_capture_platformdata capture_plat_data[] = {
#if defined(CONFIG_VIDEO_TW9900)
    {
        /* back_camera 656 interface */
        .module = 1,
        .sensor = &sensor[0],
        .type = NXP_CAPTURE_INF_PARALLEL,
        .parallel = {
            /* for 656 */
            .is_mipi        			= false,
            .external_sync  			= false, /* 656 interface */
            .h_active       			= 704,
            .h_frontporch   			= 7,
            .h_syncwidth    			= 1,
            .h_backporch    			= 10,
            .v_active       			= 480,
            .v_frontporch   			= 0,
            .v_syncwidth    			= 2,
            .v_backporch    			= 3,
            .clock_invert   			= true,
            .port           			= 0,
            .data_order     			= NXP_VIN_CBY0CRY1,
            .interlace      			= true,
            .clk_rate       			= 24000000,
            .late_power_down 			= false,
            .power_enable   			= NULL, //_sensor_power_enable,
            .power_state_changed 		= NULL,
            .set_clock      			= NULL,
            .setup_io       			= NULL, //_sensor_setup_io,
        },
        .deci = {
            .start_delay_ms = 0,
            .stop_delay_ms  = 0,
        },
    },
#endif
    { 0, NULL, 0, },
};
/* out platformdata */
static struct i2c_board_info hdmi_edid_i2c_boardinfo = {
    I2C_BOARD_INFO("nxp_edid", 0xA0>>1),
};

static struct nxp_v4l2_i2c_board_info edid = {
    .board_info = &hdmi_edid_i2c_boardinfo,
    .i2c_adapter_id = 0,
};

static struct i2c_board_info hdmi_hdcp_i2c_boardinfo = {
    I2C_BOARD_INFO("nxp_hdcp", 0x74>>1),
};

static struct nxp_v4l2_i2c_board_info hdcp = {
    .board_info = &hdmi_hdcp_i2c_boardinfo,
    .i2c_adapter_id = 0,
};


static void hdmi_set_int_external(int gpio)
{
    nxp_soc_gpio_set_int_enable(gpio, 0);
    nxp_soc_gpio_set_int_mode(gpio, 1); /* high level */
    nxp_soc_gpio_set_int_enable(gpio, 1);
    nxp_soc_gpio_clr_int_pend(gpio);
}

static void hdmi_set_int_internal(int gpio)
{
    nxp_soc_gpio_set_int_enable(gpio, 0);
    nxp_soc_gpio_set_int_mode(gpio, 0); /* low level */
    nxp_soc_gpio_set_int_enable(gpio, 1);
    nxp_soc_gpio_clr_int_pend(gpio);
}

static int hdmi_read_hpd_gpio(int gpio)
{
    return nxp_soc_gpio_get_in_value(gpio);
}

static struct nxp_out_platformdata out_plat_data = {
    .hdmi = {
        .internal_irq = 0,
        .external_irq = 0,//PAD_GPIO_A + 19,
        .set_int_external = hdmi_set_int_external,
        .set_int_internal = hdmi_set_int_internal,
        .read_hpd_gpio = hdmi_read_hpd_gpio,
        .edid = &edid,
        .hdcp = &hdcp,
    },
};

static struct nxp_v4l2_platformdata v4l2_plat_data = {
    .captures = &capture_plat_data[0],
    .out = &out_plat_data,
};

static struct platform_device nxp_v4l2_dev = {
    .name       = NXP_V4L2_DEV_NAME,
    .id         = 0,
    .dev        = {
        .platform_data = &v4l2_plat_data,
    },
};
#endif /* CONFIG_V4L2_NXP || CONFIG_V4L2_NXP_MODULE */

/*------------------------------------------------------------------------------
 * SSP/SPI
 */
#if defined(CONFIG_SPI_SPIDEV) || defined(CONFIG_SPI_SPIDEV_MODULE)
#include <linux/spi/spi.h>
static void spi0_cs(u32 chipselect)
{
#if (CFG_SPI0_CS_GPIO_MODE)
	if(nxp_soc_gpio_get_io_func( CFG_SPI0_CS )!= nxp_soc_gpio_get_altnum( CFG_SPI0_CS))
		nxp_soc_gpio_set_io_func( CFG_SPI0_CS, nxp_soc_gpio_get_altnum( CFG_SPI0_CS));

	nxp_soc_gpio_set_io_dir( CFG_SPI0_CS,1);
	nxp_soc_gpio_set_out_value(	 CFG_SPI0_CS , chipselect);
#else
	;
#endif
}

static void spi1_cs(u32 chipselect)
{
#if (CFG_SPI1_CS_GPIO_MODE)
	if(nxp_soc_gpio_get_io_func(CFG_SPI1_CS )!= nxp_soc_gpio_get_altnum(CFG_SPI1_CS))
		nxp_soc_gpio_set_io_func(CFG_SPI1_CS, nxp_soc_gpio_get_altnum(CFG_SPI1_CS));

	nxp_soc_gpio_set_io_dir(CFG_SPI1_CS,1);
	nxp_soc_gpio_set_out_value(CFG_SPI1_CS , chipselect);
#endif
}

static void spi2_cs(u32 chipselect)
{
#if (CFG_SPI2_CS_GPIO_MODE)
	if(nxp_soc_gpio_get_io_func(CFG_SPI2_CS )!= nxp_soc_gpio_get_altnum(CFG_SPI2_CS))
		nxp_soc_gpio_set_io_func(CFG_SPI2_CS, nxp_soc_gpio_get_altnum(CFG_SPI2_CS));

	nxp_soc_gpio_set_io_dir(CFG_SPI2_CS,1);
	nxp_soc_gpio_set_out_value(CFG_SPI2_CS , chipselect);
#endif
}

struct pl022_config_chip spi0_info = {
    /* available POLLING_TRANSFER, INTERRUPT_TRANSFER, DMA_TRANSFER */
    .com_mode = CFG_SPI0_COM_MODE,
    .iface = SSP_INTERFACE_MOTOROLA_SPI,
    /* We can only act as master but SSP_SLAVE is possible in theory */
    .hierarchy = SSP_MASTER,
    /* 0 = drive TX even as slave, 1 = do not drive TX as slave */
    .slave_tx_disable = 1,
    .rx_lev_trig = SSP_RX_4_OR_MORE_ELEM,
    .tx_lev_trig = SSP_TX_4_OR_MORE_EMPTY_LOC,
    .ctrl_len = SSP_BITS_8,
    .wait_state = SSP_MWIRE_WAIT_ZERO,
    .duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
    /*
     * This is where you insert a call to a function to enable CS
     * (usually GPIO) for a certain chip.
     */
#if (CFG_SPI0_CS_GPIO_MODE)
    .cs_control = spi0_cs,
#endif
	.clkdelay = SSP_FEEDBACK_CLK_DELAY_1T,

};

struct pl022_config_chip spi1_info = {
	/* available POLLING_TRANSFER, INTERRUPT_TRANSFER, DMA_TRANSFER */
	.com_mode = CFG_SPI1_COM_MODE,
	.iface = SSP_INTERFACE_MOTOROLA_SPI,
	.hierarchy = SSP_MASTER, /* We can only act as master but SSP_SLAVE is possible in theory */
	.slave_tx_disable = 1,
	/* 0 = drive TX even as slave, 1 = do not drive TX as slave */
	.rx_lev_trig = SSP_RX_4_OR_MORE_ELEM,
	.tx_lev_trig = SSP_TX_4_OR_MORE_EMPTY_LOC,
	.ctrl_len = SSP_BITS_8,
	.wait_state = SSP_MWIRE_WAIT_ZERO,
	.duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
	/* This is where you insert a call to a function to enable CS
	* (usually GPIO) for a certain chip. */
	#if (CFG_SPI1_CS_GPIO_MODE)
	.cs_control = spi1_cs,
	#endif
	.clkdelay = SSP_FEEDBACK_CLK_DELAY_1T,
};


struct pl022_config_chip spi2_info = {
	/* available POLLING_TRANSFER, INTERRUPT_TRANSFER, DMA_TRANSFER */
	.com_mode = CFG_SPI2_COM_MODE,
	.iface = SSP_INTERFACE_MOTOROLA_SPI,
	.hierarchy = SSP_MASTER, /* We can only act as master but SSP_SLAVE is possible in theory */
	.slave_tx_disable = 1,
	/* 0 = drive TX even as slave, 1 = do not drive TX as slave */
	.rx_lev_trig = SSP_RX_4_OR_MORE_ELEM,
	.tx_lev_trig = SSP_TX_4_OR_MORE_EMPTY_LOC,
	.ctrl_len = SSP_BITS_8,
	.wait_state = SSP_MWIRE_WAIT_ZERO,
	.duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
	/* This is where you insert a call to a function to enable CS
	* (usually GPIO) for a certain chip. */
	#if (CFG_SPI2_CS_GPIO_MODE)
	.cs_control = spi2_cs,
	#endif
	.clkdelay = SSP_FEEDBACK_CLK_DELAY_1T,
};
static struct spi_board_info spi_plat_board[] __initdata = {
    [0] = {
        .modalias        = "spidev",    /* fixup */
        .max_speed_hz    = 3125000,     /* max spi clock (SCK) speed in HZ */
        .bus_num         = 0,           /* Note> set bus num, must be smaller than ARRAY_SIZE(spi_plat_device) */
        .chip_select     = 0,           /* Note> set chip select num, must be smaller than spi cs_num */
        .controller_data = &spi0_info,
        .mode            = SPI_MODE_3 | SPI_CPOL | SPI_CPHA,
    },
	[1] = {
		.modalias = "mtvspi_1", /* fixup */
		.max_speed_hz = 3125000, /* max spi clock (SCK) speed in HZ */
		.bus_num = 1, /* Note> set bus num, must be smaller than ARRAY_SIZE(spi_plat_device) */
		.chip_select = 0, /* Note> set chip select num, must be smaller than spi cs_num */
		.controller_data = &spi1_info,
//		.mode = SPI_MODE_3 | SPI_CPOL | SPI_CPHA,
	},
	[2] = {
		.modalias = "mtvspi", /* fixup */
		.max_speed_hz = 3125000, /* max spi clock (SCK) speed in HZ */
		.bus_num = 2, /* Note> set bus num, must be smaller than ARRAY_SIZE(spi_plat_device) */
		.chip_select = 0, /* Note> set chip select num, must be smaller than spi cs_num */
		.controller_data = &spi2_info,
//		.mode = SPI_MODE_3 | SPI_CPOL | SPI_CPHA,
	},
};

#endif
/*------------------------------------------------------------------------------
 * DW MMC board config
 */
#if defined(CONFIG_MMC_DW)
static int _dwmci_ext_cd_init(void (*notify_func)(struct platform_device *, int state))
{
	return 0;
}

static int _dwmci_ext_cd_cleanup(void (*notify_func)(struct platform_device *, int state))
{
	return 0;
}

static int _dwmci_get_ro(u32 slot_id)
{
	return 0;
}

#ifdef CONFIG_MMC_NXP_CH0
static int _dwmci0_init(u32 slot_id, irq_handler_t handler, void *data)
{
	struct dw_mci *host = (struct dw_mci *)data;
	int io  = CFG_SDMMC0_DETECT_IO;
	int irq = IRQ_GPIO_START + io;
	int id  = 0, ret = 0;

	printk("dw_mmc dw_mmc.%d: Using external card detect irq %3d (io %2d)\n", id, irq, io);

	ret  = request_irq(irq, handler, IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
				DEV_NAME_SDHC "0", (void*)host->slot[slot_id]);
	if (0 > ret)
		pr_err("dw_mmc dw_mmc.%d: fail request interrupt %d ...\n", id, irq);
	return 0;
}

static int _dwmci0_get_cd(u32 slot_id)
{
	int io = CFG_SDMMC0_DETECT_IO;
	return nxp_soc_gpio_get_in_value(io);
}

static struct dw_mci_board _dwmci0_data = {
	.quirks			= DW_MCI_QUIRK_HIGHSPEED,
	.bus_hz			= 90 * 1000 * 1000,	// 80.. 40Mhz=>20Mhz
	.caps			= MMC_CAP_CMD23,
	.detect_delay_ms= 200,
	.clk_dly        = DW_MMC_DRIVE_DELAY(0) | DW_MMC_SAMPLE_DELAY(0) | DW_MMC_DRIVE_PHASE(2) | DW_MMC_SAMPLE_PHASE(1),
	.cd_type		= DW_MCI_CD_EXTERNAL,
//	.clk_dly        = DW_MMC_DRIVE_DELAY(0) | DW_MMC_SAMPLE_DELAY(0) | DW_MMC_DRIVE_PHASE(2) | DW_MMC_SAMPLE_PHASE(1),
	.init			= _dwmci0_init,
	.get_ro         = _dwmci_get_ro,
	.get_cd			= _dwmci0_get_cd,
	.ext_cd_init	= _dwmci_ext_cd_init,
	.ext_cd_cleanup	= _dwmci_ext_cd_cleanup,
#if defined (CONFIG_MMC_DW_IDMAC) && defined (CONFIG_MMC_NXP_CH0_USE_DMA)
	.mode       	= DMA_MODE,
#else
	.mode       	= PIO_MODE,
#endif

};
#endif

#ifdef CONFIG_MMC_NXP_CH1
static struct dw_mci_board _dwmci1_data = {
	.quirks			= DW_MCI_QUIRK_BROKEN_CARD_DETECTION |
					  DW_MCI_QUIRK_HIGHSPEED |
					  DW_MMC_QUIRK_HW_RESET_PW |
					  DW_MCI_QUIRK_NO_DETECT_EBIT,
	.bus_hz			= 200 * 1000 * 1000,
    .hs_over_clk    = 50 * 1000 * 1000,
	.caps			= MMC_CAP_UHS_DDR50 |
						MMC_CAP_NONREMOVABLE |
						MMC_CAP_4_BIT_DATA | MMC_CAP_CMD23 |
						MMC_CAP_ERASE | MMC_CAP_HW_RESET,
	.desc_sz		= 4,
	.detect_delay_ms= 200,
	.clk_dly        = DW_MMC_DRIVE_DELAY(0) | DW_MMC_SAMPLE_DELAY(0) | DW_MMC_DRIVE_PHASE(2) | DW_MMC_SAMPLE_PHASE(1),
#if defined (CONFIG_MMC_DW_IDMAC) && defined (CONFIG_MMC_NXP_CH1_USE_DMA)
	.mode       	= DMA_MODE,
#else
	.mode       	= PIO_MODE,
#endif
};
#endif

// Wifi 5G
#ifdef CONFIG_MMC_NXP_CH2
#if defined(CONFIG_BCMDHD) || defined(CONFIG_BCMDHD_MODULE)
extern int bcm_wlan_ext_cd_init(
            void (*notify_func)(struct platform_device *, int));
extern int bcm_wlan_ext_cd_cleanup(
            void (*notify_func)(struct platform_device *, int));
#endif

static struct dw_mci_board _dwmci2_data = {
	.quirks			= DW_MCI_QUIRK_BROKEN_CARD_DETECTION |
					DW_MCI_QUIRK_HIGHSPEED,
	.bus_hz			= 40 * 1000 * 1000,	// 20
	.caps           = MMC_CAP_CMD23,
	.pm_caps        = MMC_PM_KEEP_POWER | MMC_PM_IGNORE_PM_NOTIFY,
	.detect_delay_ms= 200,
#if defined(CONFIG_BCMDHD) || defined(CONFIG_BCMDHD_MODULE)
	.ext_cd_init        = bcm_wlan_ext_cd_init,
	.ext_cd_cleanup     = bcm_wlan_ext_cd_cleanup,
    .pm_caps        = MMC_PM_KEEP_POWER | MMC_PM_IGNORE_PM_NOTIFY,
	.cd_type        = DW_MCI_CD_EXTERNAL,
#else
	.cd_type        = DW_MCI_CD_NONE,
#endif
	.clk_dly		= DW_MMC_DRIVE_DELAY(0) | DW_MMC_SAMPLE_DELAY(0) | DW_MMC_DRIVE_PHASE(2) | DW_MMC_SAMPLE_PHASE(1),
#if defined (CONFIG_MMC_DW_IDMAC) && defined (CONFIG_MMC_NXP_CH2_USE_DMA)
	.mode			= DMA_MODE,
#else
	.mode			= PIO_MODE,
#endif
};
#endif

#endif /* CONFIG_MMC_DW */

/*------------------------------------------------------------------------------
 * RFKILL driver
 */
#if defined(CONFIG_NXP_RFKILL)

struct rfkill_dev_data  rfkill_dev_data =
{
	.supply_name 	= "vwifi_3.3V",	// vwifi_3.3V, vgps_3.3V
	.module_name 	= "wlan",
	.initval		= RFKILL_INIT_SET | RFKILL_INIT_OFF,
    .delay_time_off	= 1000,
};

struct nxp_rfkill_plat_data rfkill_plat_data = {
	.name		= "WiFi-Rfkill",
	.type		= RFKILL_TYPE_WLAN,
	.rf_dev		= &rfkill_dev_data,
    .rf_dev_num	= 1,
};

static struct platform_device rfkill_device = {
	.name			= DEV_NAME_RFKILL,
	.dev			= {
		.platform_data	= &rfkill_plat_data,
	}
};
#endif	/* CONFIG_RFKILL_NXP */

// s tnn, nplat
#if defined(CONFIG_PPM_NEXELL)
#include <mach/ppm.h>
struct nxp_ppm_platform_data ppm_plat_data = {
	.input_polarity = NX_PPM_INPUTPOL_INVERT,//NX_PPM_INPUTPOL_INVERT  or  NX_PPM_INPUTPOL_BYPASS
};

static struct platform_device ppm_device = {
	.name			= DEV_NAME_PPM,
	.dev			= {
		.platform_data	= &ppm_plat_data,
	}
};
#endif

static struct platform_device nplat_device = {
        .name                   = "nplat_sysfs",
};

// e tnn, nplat

/*------------------------------------------------------------------------------
 * USB HSIC power control.
 */
int nxp_hsic_phy_pwr_on(struct platform_device *pdev, bool on)
{
	return 0;
}
EXPORT_SYMBOL(nxp_hsic_phy_pwr_on);

/*------------------------------------------------------------------------------
 * HDMI CEC driver
 */
#if defined(CONFIG_NXP_HDMI_CEC)
static struct platform_device hdmi_cec_device = {
	.name			= NXP_HDMI_CEC_DRV_NAME,
};
#endif /* CONFIG_NXP_HDMI_CEC */

#ifdef CONFIG_BATTERY_NXE2000
/*------------------------------------------------------------------------------
 * USB OTGVBUS power control.
 */
void nxp_otgvbus_pwr_set(int enable)
{
	nxp_soc_gpio_set_out_value(CFG_GPIO_OTG_VBUS_DET, enable);
}
EXPORT_SYMBOL(nxp_otgvbus_pwr_set);
#endif
/*------------------------------------------------------------------------------
 * Backward Camera driver
 */
#if defined(CONFIG_SLSIAP_BACKWARD_CAMERA)
#include <mach/nxp-backward-camera.h>
#if 0
static struct reg_val _sensor_init_data[] =
{
    {0x03, 0xa6},
    {0x07, 0x02},
    {0x08, 0x12},
    {0x09, 0xf0},
    {0x0a, 0x1c},
    /*{0x0b, 0xd0}, // 720 */
    {0x0b, 0xc0}, // 704
    {0x1b, 0x00},
    {0x10, 0x10},
    {0x11, 0x42},
    {0x2f, 0xe6},
    {0x55, 0x00},
    END_MARKER
};
#else
	static struct reg_val _sensor_init_data[] =
	{
		{0x02, 0x40},
		//{0x02, 0x44},
		{0x03, 0xa2},
		{0x07, 0x02},
		{0x08, 0x12},
		{0x09, 0xf0},
		{0x0a, 0x1c},
		/*{0x0b, 0xd0}, // 720 */
		{0x0b, 0xc0}, // 704
		{0x1b, 0x00},
		/*{0x10, 0xfa},*/
		{0x10, 0x1e},
		{0x11, 0x64},
		{0x2f, 0xe6},
		{0x55, 0x00},
#if 1
		/*{0xb1, 0x20},*/
		/*{0xb1, 0x02},*/
		{0xaf, 0x00},
		{0xb1, 0x20},
		{0xb4, 0x20},
		/*{0x06, 0x80},*/
#endif
		/*{0xaf, 0x40},*/
		/*{0xaf, 0x00},*/
		/*{0xaf, 0x80},*/
		END_MARKER
	};
#endif

#define CAMERA_RESET        ((PAD_GPIO_C + 15) | PAD_FUNC_ALT1)
#define CAMERA_POWER_DOWN   ((PAD_GPIO_C + 16) | PAD_FUNC_ALT1)
static int _sensor_power_enable(bool enable)
{
    u32 io = CAMERA_POWER_DOWN;
    u32 reset_io = CAMERA_RESET;

    if (enable) {
        // disable power down
        nxp_soc_gpio_set_out_value(io & 0xff, 0);
        nxp_soc_gpio_set_io_dir(io & 0xff, 1);
        nxp_soc_gpio_set_io_func(io & 0xff, nxp_soc_gpio_get_altnum(io));

        // reset to high
        nxp_soc_gpio_set_out_value(reset_io & 0xff, 1);
        nxp_soc_gpio_set_io_dir(reset_io & 0xff, 1);
        nxp_soc_gpio_set_io_func(reset_io & 0xff, nxp_soc_gpio_get_altnum(reset_io));
        mdelay(1);

        // reset to low
        nxp_soc_gpio_set_out_value(reset_io & 0xff, 0);
        mdelay(10);

        // reset to high
        nxp_soc_gpio_set_out_value(reset_io & 0xff, 1);
        mdelay(10);
    }

    return 0;
}

static void _sensor_setup_io(void)
{
    u_int *pad;
    int i, len;
    u_int io, fn;

    /* VIP0:0 = VCLK, VID0 ~ 7 */
    const u_int port[][2] = {
        /* VCLK, HSYNC, VSYNC */
        { PAD_GPIO_E +  4, NX_GPIO_PADFUNC_1 },
        { PAD_GPIO_E +  5, NX_GPIO_PADFUNC_1 },
        { PAD_GPIO_E +  6, NX_GPIO_PADFUNC_1 },
        /* DATA */
        { PAD_GPIO_D + 28, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_D + 29, NX_GPIO_PADFUNC_1 },
        { PAD_GPIO_D + 30, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_D + 31, NX_GPIO_PADFUNC_1 },
        { PAD_GPIO_E +  0, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_E +  1, NX_GPIO_PADFUNC_1 },
        { PAD_GPIO_E +  2, NX_GPIO_PADFUNC_1 }, { PAD_GPIO_E +  3, NX_GPIO_PADFUNC_1 },
    };

    pad = (u_int *)port;
    len = sizeof(port)/sizeof(port[0]);

    for (i = 0; i < len; i++) {
        io = *pad++;
        fn = *pad++;
        nxp_soc_gpio_set_io_dir(io, 0);
        nxp_soc_gpio_set_io_func(io, fn);
    }
}

// This is callback function for rgb overlay drawing
static void _draw_rgb_overlay(struct nxp_backward_camera_platform_data *plat_data, void *mem)
{
    printk("%s\n", __func__);
#if 1 // tnn
    int horizon,vertic;
	int pos = 0;
	int vertical_adj = 70; // 50
    u32 *addr = (u32 *)mem;

    memset(addr, 0, plat_data->width*plat_data->height*4);
	
	addr += 0;
	for ( vertic=0; vertic<plat_data->height; vertic++){
		for(horizon =0; horizon< plat_data->width; horizon++) {
			if(line_data[pos][0] == line_data[pos+1][0]) {				
				if(vertic >= (line_data[pos][0]+ vertical_adj) && horizon>= line_data[pos][1] && horizon <= line_data[pos+1][1]){
					if( vertic <= 200)
						*addr = 0xffff0000;	// red
					else if(vertic >= 200 && vertic <= 320) 
						*addr = 0xffffaa00;	// yellow
					else
						*addr = 0xff00ff00;	// green

					if(horizon == line_data[pos+1][1]) pos+=2;
				}
			}
			addr++;
		}
	}
#else
    memset(mem, 0, plat_data->width*plat_data->height*4);
    /* draw redbox at (0, 0) -- (50, 50) */
    {    
        u32 color = 0xFFFF0000;
        int i, j;
        u32 *pbuffer = (u32 *)mem;
        for(i=0; i<50 ; i++) {
            for(j=0; j<50 ;  j++) {
                pbuffer[i * 1024 + j] = color;
            }
        }
    }    
#endif
}

#define BACKWARD_CAM_WIDTH  704
#define BACKWARD_CAM_HEIGHT 480

static struct nxp_backward_camera_platform_data backward_camera_plat_data = {
    .backgear_gpio_num  = CFG_BACKWARD_GEAR,
    //.active_high        = false,	// tnn
    .active_high        = true,	// tnn
    .vip_module_num     = 1,
    .mlc_module_num     = 0,

    // sensor
    .i2c_bus            = 0,
    .chip_addr          = 0x88 >> 1,
    .reg_val            = _sensor_init_data,
    .power_enable       = _sensor_power_enable,
    .set_clock          = NULL,
    .setup_io           = _sensor_setup_io,

    // vip
    .port               = 0,
    .external_sync      = false,
    .is_mipi            = false,
    .h_active           = BACKWARD_CAM_WIDTH,
    .h_frontporch       = 7,
    .h_syncwidth        = 1,
    .h_backporch        = 10,
    .v_active           = BACKWARD_CAM_HEIGHT,
    .v_frontporch       = 0,
    .v_syncwidth        = 2,
    .v_backporch        = 3,
    .data_order         = 0,
    .interlace          = true,
#if 0
    .lu_addr            = 0x7FD28000,
    .cb_addr            = 0x7FD7A800,
    .cr_addr            = 0x7FD91000,
#else
    .lu_addr            = 0,
    .cb_addr            = 0,
    .cr_addr            = 0,
#endif

    .lu_stride          = 704,
    .cb_stride          = 384,
    .cr_stride          = 384,

    .rgb_format         = MLC_RGBFMT_A8R8G8B8,
    .width              = 1024,
    .height             = 600,
#if 0
    .rgb_addr           = 0x7FDA8000,
#else
    .rgb_addr           = 0,
#endif
    .draw_rgb_overlay   = _draw_rgb_overlay,
};

/*static struct platform_device backward_camera_device = {*/
struct platform_device backward_camera_device = {
    .name           = "nxp-backward-camera",
    .dev			= {
        .platform_data	= &backward_camera_plat_data,
    }
};

#ifdef CONFIG_SLSIAP_NXPBOOT
extern void register_backward_camera(struct platform_device *device);
#endif
#endif

/*------------------------------------------------------------------------------
 * register board platform devices
 */
void __init nxp_board_devices_register(void)
{
	printk("[Register board platform devices]\n");

#if defined(CONFIG_ARM_NXP_CPUFREQ)
	printk("plat: add dynamic frequency (pll.%d)\n", dfs_plat_data.pll_dev);
	platform_device_register(&dfs_plat_device);
#endif

#if defined (CONFIG_FB_NXP)
	printk("plat: add framebuffer\n");
	platform_add_devices(fb_devices, ARRAY_SIZE(fb_devices));
#endif

#if defined(CONFIG_MMC_DW)
    #ifdef CONFIG_MMC_NXP_CH1
	nxp_mmc_add_device(1, &_dwmci1_data);
	#endif
	#ifdef CONFIG_MMC_NXP_CH0
	nxp_mmc_add_device(0, &_dwmci0_data);
	#endif
    #ifdef CONFIG_MMC_NXP_CH2
	nxp_mmc_add_device(2, &_dwmci2_data);
	#endif
#endif

#if defined(CONFIG_DM9000) || defined(CONFIG_DM9000_MODULE)
	printk("plat: add device dm9000 net\n");
	platform_device_register(&dm9000_plat_device);
#endif

#if defined(CONFIG_BACKLIGHT_PWM)
	printk("plat: add backlight pwm device\n");
	platform_device_register(&bl_plat_device);
#endif

#if defined(CONFIG_TOUCHSCREEN_FT5X0X)
	printk("plat: add touch(ftx0x) device\n");
	i2c_register_board_info(FT5X0X_I2C_BUS, &ft5x0x_i2c_bdi, 1);
#endif

/* tnn mid s*/
#if defined(CONFIG_TOUCHSCREEN_GOODIX)
	printk("plat: add touch(goodix) device\n");
	i2c_register_board_info(GOODIX_I2C_BUS, &goodix_i2c_bdi, 1);
#endif
/* tnn mid e*/

#if defined(CONFIG_TOUCHSCREEN_ATMEL_MXT)
	printk("plat: add touch(atmel_mxt_ts) device\n");
	atmel_i2c_boardinfo[0].irq = PB_PIO_IRQ(CFG_IO_TOUCH_PENDOWN_DETECT);
	i2c_register_board_info(ATMEL_I2C_BUS, atmel_i2c_boardinfo, ARRAY_SIZE(atmel_i2c_boardinfo));
#endif

#if defined(CONFIG_MTD_NAND_NXP)
	platform_device_register(&nand_plat_device);
#endif

#if defined(CONFIG_KEYBOARD_NXP_KEY) || defined(CONFIG_KEYBOARD_NXP_KEY_MODULE)
	printk("plat: add device keypad\n");
	platform_device_register(&key_plat_device);
#endif

#if defined(CONFIG_REGULATOR_NXE2000)
	printk("plat: add device nxe2000 pmic\n");
	i2c_register_board_info(NXE2000_I2C_BUS, nxe2000_i2c_boardinfo, ARRAY_SIZE(nxe2000_i2c_boardinfo));
#endif

#if defined(CONFIG_SND_SPDIF_TRANSCIEVER) || defined(CONFIG_SND_SPDIF_TRANSCIEVER_MODULE)
	printk("plat: add device spdif playback\n");
	platform_device_register(&spdif_transciever);
	platform_device_register(&spdif_trans_dai);
#endif

#if defined(CONFIG_SND_CODEC_ES8316) || defined(CONFIG_SND_CODEC_ES8316_MODULE)
	printk("plat: add device asoc-es8316\n");
	i2c_register_board_info(ES8316_I2C_BUS, &es8316_i2c_bdi, 1);
	platform_device_register(&es8316_dai);
#endif

/* tnn mid s*/
#if defined(CONFIG_SND_CODEC_ALC5633)
        printk("plat: add device asoc-alc5633\n");
        i2c_register_board_info(ALC5633_I2C_BUS, &alc5633_i2c_bdi, 1);
        platform_device_register(&alc5633_dai);
#endif
/* tnn mid e*/
#if defined(CONFIG_SND_CODEC_ALCDUMMY)
        printk("plat: add device asoc-alcdummy\n");
        i2c_register_board_info(ALCDUMMY_I2C_BUS, &alcdummy_i2c_bdi, 1);
        platform_device_register(&alcdummy_dai);
#endif

#if defined(CONFIG_V4L2_NXP) || defined(CONFIG_V4L2_NXP_MODULE)
    printk("plat: add device nxp-v4l2\n");
    platform_device_register(&nxp_v4l2_dev);
#endif

#if defined(CONFIG_SPI_SPIDEV) || defined(CONFIG_SPI_SPIDEV_MODULE)
    spi_register_board_info(spi_plat_board, ARRAY_SIZE(spi_plat_board));
    printk("plat: register spidev\n");
#endif

#if defined(CONFIG_TOUCHSCREEN_GSLX680)
	printk("plat: add touch(gslX680) device\n");
	i2c_register_board_info(GSLX680_I2C_BUS, &gslX680_i2c_bdi, 1);
#endif

#if defined(CONFIG_SENSORS_MMA865X) || defined(CONFIG_SENSORS_MMA865X_MODULE)
	printk("plat: add g-sensor mma865x\n");
	i2c_register_board_info(2, &mma865x_i2c_bdi, 1);
#elif defined(CONFIG_SENSORS_MMA7660) || defined(CONFIG_SENSORS_MMA7660_MODULE)
	printk("plat: add g-sensor mma7660\n");
	i2c_register_board_info(MMA7660_I2C_BUS, &mma7660_i2c_bdi, 1);
#endif

#if defined(CONFIG_RFKILL_NXP)
    printk("plat: add device rfkill\n");
    platform_device_register(&rfkill_device);
#endif

#if defined(CONFIG_NXP_HDMI_CEC)
    printk("plat: add device hdmi-cec\n");
    platform_device_register(&hdmi_cec_device);
#endif

#if defined(CONFIG_SLSIAP_BACKWARD_CAMERA)
	printk("plat: register device backward-camera platform device to tnn-boot\n");
#if 0//def CONFIG_SLSIAP_NXPBOOT
    register_backward_camera(&backward_camera_device);
#else
    platform_device_register(&backward_camera_device);
#endif
#endif
//s tnn, nplat
#if defined(CONFIG_PPM_NEXELL)
    printk("plat: add device ppm\n");
    platform_device_register(&ppm_device);
#endif

    printk("plat: add device nplat\n");
    platform_device_register(&nplat_device);
#if defined(CONFIG_BCMDHD)
	init_bcm_wifi();
#endif
// e tnn, nplat
	/* END */
	printk("\n");
}
