/*
 * MELFAS MIP4 Touchscreen
 *
 * Copyright (C) 2016 MELFAS Inc.
 *
 *
 * mip4_ts_dev.c : Development functions (Optional)
 *
 * Version : 2016.09.08
 */

#include "mip4_ts.h"

#if USE_DEV

/*
* Dev node output to user
*/
static ssize_t mip4_ts_dev_fs_read(struct file *fp, char *rbuf, size_t cnt, loff_t *fpos)
{
	struct mip4_ts_info *info = fp->private_data;
	int ret = 0;

	//dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	ret = copy_to_user(rbuf, info->dev_fs_buf, cnt);

	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);

	return ret;
}

/*
* Dev node input from user
*/
static ssize_t mip4_ts_dev_fs_write(struct file *fp, const char *wbuf, size_t cnt, loff_t *fpos)
{
	struct mip4_ts_info *info = fp->private_data;
	u8 *buf;
	int ret = 0;
	int cmd = 0;

	//dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	buf = kzalloc(cnt + 1, GFP_KERNEL);

	if ((buf == NULL) || copy_from_user(buf, wbuf, cnt)) {
		dev_err(&info->client->dev, "%s [ERROR] copy_from_user\n", __func__);
		ret = -EIO;
		goto exit;
	}

	cmd = buf[cnt - 1];

	if (cmd == 1) {
		//dev_dbg(&info->client->dev, "%s - cmd[%d] w_len[%d] r_len[%d]\n", __func__, cmd, (cnt - 2), buf[cnt - 2]);
		if (mip4_ts_i2c_read(info, buf, (cnt - 2), info->dev_fs_buf, buf[cnt - 2])) {
			dev_err(&info->client->dev, "%s [ERROR] mip4_ts_i2c_read\n", __func__);
		}
	} else if (cmd == 2) {
		//dev_dbg(&info->client->dev, "%s - cmd[%d] w_len[%d]\n", __func__, cmd, (cnt - 1));
		if (mip4_ts_i2c_write(info, buf, (cnt - 1))) {
			dev_err(&info->client->dev, "%s [ERROR] mip4_ts_i2c_write\n", __func__);
		}
	} else {
		goto exit;
	}

exit:
	kfree(buf);

	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
	return ret;
}

/*
* Open dev node
*/
static int mip4_ts_dev_fs_open(struct inode *node, struct file *fp)
{
	struct mip4_ts_info *info = container_of(node->i_cdev, struct mip4_ts_info, cdev);

	//dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	fp->private_data = info;
	info->dev_fs_buf = kzalloc(1024 * 4, GFP_KERNEL);

	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
	return 0;
}

/*
* Close dev node
*/
static int mip4_ts_dev_fs_release(struct inode *node, struct file *fp)
{
	struct mip4_ts_info *info = fp->private_data;

	//dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	kfree(info->dev_fs_buf);

	//dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
	return 0;
}

/*
* Dev node info
*/
static struct file_operations mip4_ts_dev_fops = {
	.owner = THIS_MODULE,
	.open = mip4_ts_dev_fs_open,
	.release = mip4_ts_dev_fs_release,
	.read = mip4_ts_dev_fs_read,
	.write = mip4_ts_dev_fs_write,
};

/*
* Create dev node
*/
int mip4_ts_dev_create(struct mip4_ts_info *info)
{
	struct i2c_client *client = info->client;
	int ret = 0;

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	if (alloc_chrdev_region(&info->mip4_ts_dev, 0, 1, MIP4_TS_DEVICE_NAME)) {
		dev_err(&client->dev, "%s [ERROR] alloc_chrdev_region\n", __func__);
		ret = -ENOMEM;
		goto error;
	}

	cdev_init(&info->cdev, &mip4_ts_dev_fops);
	info->cdev.owner = THIS_MODULE;

	if (cdev_add(&info->cdev, info->mip4_ts_dev, 1)) {
		dev_err(&client->dev, "%s [ERROR] cdev_add\n", __func__);
		ret = -EIO;
		goto error;
	}

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
	return 0;

error:
	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
	return 0;
}

#endif

#if (USE_SYS || USE_CMD)
/*
* Process table data
*/
static int mip4_ts_proc_table_data(struct mip4_ts_info *info, u8 data_type_size, u8 data_type_sign, u8 buf_addr_h, u8 buf_addr_l, u8 row_num, u8 col_num, u8 buf_col_num, u8 rotate)
{
	char data[10];
	int i_col, i_row, i_x, i_y;
	int max_x = 0;
	int max_y = 0;
	int sValue = 0;
	unsigned int uValue = 0;
	int value = 0;
	int size = 0;
	u8 wbuf[8];
	u8 rbuf[512];
	unsigned int buf_addr;
	int offset;

	memset(data, 0, 10);

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	//set axis
	if (rotate == 0) {
		max_x = col_num;
		max_y = row_num;
	} else if (rotate == 1) {
		max_x = row_num;
		max_y = col_num;
	} else {
		dev_err(&info->client->dev, "%s [ERROR] rotate[%d]\n", __func__, rotate);
		goto error;
	}

	//get table data
	for (i_row = 0; i_row < row_num; i_row++) {
		//get line data
		offset = buf_col_num * data_type_size;
		size = col_num * data_type_size;
		buf_addr = (buf_addr_h << 8) | buf_addr_l | (offset * i_row);

		wbuf[0] = (buf_addr >> 8) & 0xFF;
		wbuf[1] = buf_addr & 0xFF;
		if (mip4_ts_i2c_read(info, wbuf, 2, rbuf, size)) {
			dev_err(&info->client->dev, "%s [ERROR] Read data buffer\n", __func__);
			goto error;
		}

		//save data
		for (i_col = 0; i_col < col_num; i_col++) {
			if (data_type_sign == 0) {
				//unsigned
				switch (data_type_size) {
				case 1:
					uValue = (u8)rbuf[i_col];
					break;
				case 2:
					uValue = (u16)(rbuf[data_type_size * i_col] | (rbuf[data_type_size * i_col + 1] << 8));
					break;
				case 4:
					uValue = (u32)(rbuf[data_type_size * i_col] | (rbuf[data_type_size * i_col + 1] << 8) | (rbuf[data_type_size * i_col + 2] << 16) | (rbuf[data_type_size * i_col + 3] << 24));
					break;
				default:
					dev_err(&info->client->dev, "%s [ERROR] data_type_size[%d]\n", __func__, data_type_size);
					goto error;
					break;
				}
				value = (int)uValue;
			} else {
				//signed
				switch (data_type_size) {
				case 1:
					sValue = (s8)rbuf[i_col];
					break;
				case 2:
					sValue = (s16)(rbuf[data_type_size * i_col] | (rbuf[data_type_size * i_col + 1] << 8));
					break;
				case 4:
					sValue = (s32)(rbuf[data_type_size * i_col] | (rbuf[data_type_size * i_col + 1] << 8) | (rbuf[data_type_size * i_col + 2] << 16) | (rbuf[data_type_size * i_col + 3] << 24));
					break;
				default:
					dev_err(&info->client->dev, "%s [ERROR] data_type_size[%d]\n", __func__, data_type_size);
					goto error;
					break;
				}
				value = (int)sValue;
			}

			switch (rotate) {
			case 0:
				info->image_buf[i_row * col_num + i_col] = value;
				break;
			case 1:
				info->image_buf[i_col * row_num + (row_num - 1 - i_row)] = value;
				break;
			default:
				dev_err(&info->client->dev, "%s [ERROR] rotate[%d]\n", __func__, rotate);
				goto error;
				break;
			}
		}
	}

	//print table header
	printk("    ");
	sprintf(data, "    ");
	strcat(info->print_buf, data);
	memset(data, 0, 10);

	switch (data_type_size) {
	case 1:
		for (i_x = 0; i_x < max_x; i_x++) {
			printk("[%2d]", i_x);
			sprintf(data, "[%2d]", i_x);
			strcat(info->print_buf, data);
			memset(data, 0, 10);
		}
		break;
	case 2:
		for (i_x = 0; i_x < max_x; i_x++) {
			printk("[%4d]", i_x);
			sprintf(data, "[%4d]", i_x);
			strcat(info->print_buf, data);
			memset(data, 0, 10);
		}
		break;
	case 4:
		for (i_x = 0; i_x < max_x; i_x++) {
			printk("[%5d]", i_x);
			sprintf(data, "[%5d]", i_x);
			strcat(info->print_buf, data);
			memset(data, 0, 10);
		}
		break;
	default:
		dev_err(&info->client->dev, "%s [ERROR] data_type_size[%d]\n", __func__, data_type_size);
		goto error;
		break;
	}

	printk("\n");
	sprintf(data, "\n");
	strcat(info->print_buf, data);
	memset(data, 0, 10);

	//print table
	for (i_y = 0; i_y < max_y; i_y++) {
		//print line header
		printk("[%2d]", i_y);
		sprintf(data, "[%2d]", i_y);
		strcat(info->print_buf, data);
		memset(data, 0, 10);

		//print line
		for (i_x = 0; i_x < max_x; i_x++) {
			switch (data_type_size) {
			case 1:
				printk(" %3d", info->image_buf[i_y * max_x + i_x]);
				sprintf(data, " %3d", info->image_buf[i_y * max_x + i_x]);
				break;
			case 2:
				printk(" %5d", info->image_buf[i_y * max_x + i_x]);
				sprintf(data, " %5d", info->image_buf[i_y * max_x + i_x]);
				break;
			case 4:
				printk(" %6d", info->image_buf[i_y * max_x + i_x]);
				sprintf(data, " %6d", info->image_buf[i_y * max_x + i_x]);
				break;
			default:
				dev_err(&info->client->dev, "%s [ERROR] data_type_size[%d]\n", __func__, data_type_size);
				goto error;
				break;
			}

			strcat(info->print_buf, data);
			memset(data, 0, 10);
		}

		printk("\n");
		sprintf(data, "\n");
		strcat(info->print_buf, data);
		memset(data, 0, 10);
	}

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
	return 0;

error:
	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
	return 1;
}

/*
* Process vector data
*/
static int mip4_ts_proc_vector_data(struct mip4_ts_info *info, u8 data_type_size, u8 data_type_sign, u8 buf_addr_h, u8 buf_addr_l, u8 key_num, u8 vector_num, u16 *vector_id, u16 *vector_elem_num, int table_size)
{
	char data[10];
	int i, i_line, i_vector, i_elem;
	int sValue = 0;
	unsigned int uValue = 0;
	int value = 0;
	int size = 0;
	u8 wbuf[8];
	u8 rbuf[512];
	unsigned int buf_addr;
	int key_exist = 0;
	int total_len = 0;
	int elem_len = 0;
	int vector_total_len = 0;

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	memset(data, 0, 10);

	for (i = 0; i < vector_num; i++) {
		vector_total_len += vector_elem_num[i];
	}
	total_len = key_num + vector_total_len;

	for (i = 0; i < vector_num; i++) {
		dev_dbg(&info->client->dev, "%s - vector_elem_num(%d)[%d]\n", __func__, i, vector_elem_num[i]);
	}
	dev_dbg(&info->client->dev, "%s - key_num[%d] total_len[%d]\n", __func__, key_num, total_len);

	if (key_num > 0) {
		key_exist = 1;
	} else {
		key_exist = 0;
	}

	//get line data
	size = (key_num + vector_total_len) * data_type_size;
	buf_addr = (buf_addr_h << 8) | buf_addr_l;

	wbuf[0] = (buf_addr >> 8) & 0xFF;
	wbuf[1] = buf_addr & 0xFF;
	if (mip4_ts_i2c_read(info, wbuf, 2, rbuf, size)) {
		dev_err(&info->client->dev, "%s [ERROR] Read data buffer\n", __func__);
		goto error;
	}

	//save data
	for (i = 0; i < total_len; i++) {
		if (data_type_sign == 0) {
			//unsigned
			switch (data_type_size) {
			case 1:
				uValue = (u8)rbuf[i];
				break;
			case 2:
				uValue = (u16)(rbuf[data_type_size * i] | (rbuf[data_type_size * i + 1] << 8));
				break;
			case 4:
				uValue = (u32)(rbuf[data_type_size * i] | (rbuf[data_type_size * i + 1] << 8) | (rbuf[data_type_size * i + 2] << 16) | (rbuf[data_type_size * i + 3] << 24));
				break;
			default:
				dev_err(&info->client->dev, "%s [ERROR] data_type_size[%d]\n", __func__, data_type_size);
				goto error;
				break;
			}
			value = (int)uValue;
		} else {
			//signed
			switch (data_type_size) {
			case 1:
				sValue = (s8)rbuf[i];
				break;
			case 2:
				sValue = (s16)(rbuf[data_type_size * i] | (rbuf[data_type_size * i + 1] << 8));
				break;
			case 4:
				sValue = (s32)(rbuf[data_type_size * i] | (rbuf[data_type_size * i + 1] << 8) | (rbuf[data_type_size * i + 2] << 16) | (rbuf[data_type_size * i + 3] << 24));
				break;
			default:
				dev_err(&info->client->dev, "%s [ERROR] data_type_size[%d]\n", __func__, data_type_size);
				goto error;
				break;
			}
			value = (int)sValue;
		}

		info->image_buf[table_size + i] = value;
	}

	//print header
	i_vector = 0;
	i_elem = 0;
	for (i_line = 0; i_line < (key_exist + vector_num); i_line++) {
		if ((i_line == 0) && (key_exist == 1)) {
			elem_len = key_num;
			printk("[Key]");
			sprintf(data, "[Key]");
		} else {
			elem_len = vector_elem_num[i_vector];
			if (elem_len <= 0) {
				continue;
			}
			switch (vector_id[i_vector]) {
			case 1:
				printk("[Screen Rx]");
				sprintf(data, "[Screen Rx]");
				break;
			case 2:
				printk("[Screen Tx]");
				sprintf(data, "[Screen Tx]");
				break;
			case 3:
				printk("[Key Rx]");
				sprintf(data, "[Key Rx]");
				break;
			case 4:
				printk("[Key Tx]");
				sprintf(data, "[Key Tx]");
				break;
			case 5:
				printk("[Pressure]");
				sprintf(data, "[Pressure]");
				break;
			default:
				printk("[Vector %d]", i_vector);
				sprintf(data, "[Vector %d]", i_vector);
				break;
			}
			i_vector++;
		}
		strcat(info->print_buf, data);
		memset(data, 0, 10);

		//print line
		for (i = i_elem; i < (i_elem + elem_len); i++) {
			switch (data_type_size) {
			case 1:
				printk(" %3d", info->image_buf[table_size + i]);
				sprintf(data, " %3d", info->image_buf[table_size + i]);
				break;
			case 2:
				printk(" %5d", info->image_buf[table_size + i]);
				sprintf(data, " %5d", info->image_buf[table_size + i]);
				break;
			case 4:
				printk(" %6d", info->image_buf[table_size + i]);
				sprintf(data, " %6d", info->image_buf[table_size + i]);
				break;
			default:
				dev_err(&info->client->dev, "%s [ERROR] data_type_size[%d]\n", __func__, data_type_size);
				goto error;
				break;
			}

			strcat(info->print_buf, data);
			memset(data, 0, 10);
		}

		printk("\n");
		sprintf(data, "\n");
		strcat(info->print_buf, data);
		memset(data, 0, 10);

		i_elem += elem_len;
	}

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
	return 0;

error:
	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
	return 1;
}

/*
* Run test
*/
int mip4_ts_run_test(struct mip4_ts_info *info, u8 test_type)
{
	int busy_cnt = 100;
	int wait_cnt = 0;
	int wait_num = 200;
	u8 wbuf[8];
	u8 rbuf[512];
	u8 row_num;
	u8 col_num;
	u8 buffer_col_num;
	u8 rotate;
	u8 key_num;
	u8 data_type;
	u8 data_type_size;
	u8 data_type_sign;
	u8 vector_num = 0;
	u16 vector_id[16];
	u16 vector_elem_num[16];
	u8 buf_addr_h;
	u8 buf_addr_l;
	u16 buf_addr;
	int table_size;
	int i;
	int ret = 0;

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
	dev_dbg(&info->client->dev, "%s - test_type[%d]\n", __func__, test_type);

	while (busy_cnt--) {
		if (info->test_busy == false) {
			break;
		}
		msleep(10);
	}
	mutex_lock(&info->lock);
	disable_irq(info->irq);
	info->test_busy = true;
	mutex_unlock(&info->lock);

	memset(info->print_buf, 0, PAGE_SIZE);

	//disable touch event
	wbuf[0] = MIP4_R0_CTRL;
	wbuf[1] = MIP4_R1_CTRL_EVENT_TRIGGER_TYPE;
	wbuf[2] = MIP4_CTRL_TRIGGER_NONE;
	if (mip4_ts_i2c_write(info, wbuf, 3)) {
		dev_err(&info->client->dev, "%s [ERROR] Disable event\n", __func__);
		goto error;
	}

	//check test type
	switch (test_type) {
	case MIP4_TEST_TYPE_CM:
		dev_dbg(&info->client->dev, "=== Cm Test ===\n");
		sprintf(info->print_buf, "\n=== Cm Test ===\n\n");
		break;
	case MIP4_TEST_TYPE_CM_ABS:
		dev_dbg(&info->client->dev, "=== Cm Abs Test ===\n");
		sprintf(info->print_buf, "\n=== Cm Abs Test ===\n\n");
		break;
	case MIP4_TEST_TYPE_CM_JITTER:
		dev_dbg(&info->client->dev, "=== Cm Jitter Test ===\n");
		sprintf(info->print_buf, "\n=== Cm Jitter Test ===\n\n");
		break;
	case MIP4_TEST_TYPE_CM_DIFF_HOR:
		dev_dbg(&info->client->dev, "=== Cm Diff (Horizontal) Test ===\n");
		sprintf(info->print_buf, "\n=== Cm Diff (Horizontal) Test ===\n\n");
		break;
	case MIP4_TEST_TYPE_CM_DIFF_VER:
		dev_dbg(&info->client->dev, "=== Cm Diff (Vertical) Test ===\n");
		sprintf(info->print_buf, "\n=== Cm Diff (Vertical) Test ===\n\n");
		break;
	case MIP4_TEST_TYPE_CP:
		dev_dbg(&info->client->dev, "=== Cp Test ===\n");
		sprintf(info->print_buf, "\n=== Cp Test ===\n\n");
		break;
	case MIP4_TEST_TYPE_CP_LOW:
		dev_dbg(&info->client->dev, "=== Cp (Low Freq) Test ===\n");
		sprintf(info->print_buf, "\n=== Cp (Low Freq) Test ===\n\n");
		break;
	case MIP4_TEST_TYPE_CP_HIGH:
		dev_dbg(&info->client->dev, "=== Cp (High Freq) Test ===\n");
		sprintf(info->print_buf, "\n=== Cp (High Freq) Test ===\n\n");
		break;
	case MIP4_TEST_TYPE_CP_JITTER:
		dev_dbg(&info->client->dev, "=== Cp Jitter Test ===\n");
		sprintf(info->print_buf, "\n=== Cp Jitter Test ===\n\n");
		break;
	case MIP4_TEST_TYPE_CP_DIFF_HOR:
		dev_dbg(&info->client->dev, "=== Cp Diff (Horizontal) Test ===\n");
		sprintf(info->print_buf, "\n=== Cp Diff (Horizontal) Test ===\n\n");
		break;
	case MIP4_TEST_TYPE_CP_DIFF_VER:
		dev_dbg(&info->client->dev, "=== Cp Diff (Vertical) Test ===\n");
		sprintf(info->print_buf, "\n=== Cp Diff (Vertical) Test ===\n\n");
		break;
	case MIP4_TEST_TYPE_CP_SHORT:
		dev_dbg(&info->client->dev, "=== Cp Short Test ===\n");
		sprintf(info->print_buf, "\n=== Cp Short Test ===\n\n");
		break;
	case MIP4_TEST_TYPE_CP_LPM:
		dev_dbg(&info->client->dev, "=== Cp (LPM) Test ===\n");
		sprintf(info->print_buf, "\n=== Cp (LPM) Test ===\n\n");
		break;
	case MIP4_TEST_TYPE_SHORT:
		dev_dbg(&info->client->dev, "=== Short Test ===\n");
		sprintf(info->print_buf, "\n=== Short Test ===\n\n");
		break;
	default:
		dev_err(&info->client->dev, "%s [ERROR] Unknown test type\n", __func__);
		sprintf(info->print_buf, "\nERROR : Unknown test type\n\n");
		goto error;
		break;
	}

	//set test mode
	wbuf[0] = MIP4_R0_CTRL;
	wbuf[1] = MIP4_R1_CTRL_MODE;
	wbuf[2] = MIP4_CTRL_MODE_TEST;
	if (mip4_ts_i2c_write(info, wbuf, 3)) {
		dev_err(&info->client->dev, "%s [ERROR] Write test mode\n", __func__);
		goto error;
	}

	//wait ready status
	wait_cnt = wait_num;
	while (wait_cnt--) {
		if (mip4_ts_get_ready_status(info) == MIP4_CTRL_STATUS_READY) {
			break;
		}
		msleep(10);

		dev_dbg(&info->client->dev, "%s - wait[%d]\n", __func__, wait_cnt);
	}

	if (wait_cnt <= 0) {
		dev_err(&info->client->dev, "%s [ERROR] Wait timeout\n", __func__);
		goto error;
	}

	dev_dbg(&info->client->dev, "%s - set control mode\n", __func__);

	//set test type
	wbuf[0] = MIP4_R0_TEST;
	wbuf[1] = MIP4_R1_TEST_TYPE;
	wbuf[2] = test_type;
	if (mip4_ts_i2c_write(info, wbuf, 3)) {
		dev_err(&info->client->dev, "%s [ERROR] Write test type\n", __func__);
		goto error;
	}

	dev_dbg(&info->client->dev, "%s - set test type\n", __func__);

	//wait ready status
	wait_cnt = wait_num;
	while (wait_cnt--) {
		if (mip4_ts_get_ready_status(info) == MIP4_CTRL_STATUS_READY) {
			break;
		}
		msleep(10);

		dev_dbg(&info->client->dev, "%s - wait[%d]\n", __func__, wait_cnt);
	}

	if (wait_cnt <= 0) {
		dev_err(&info->client->dev, "%s [ERROR] Wait timeout\n", __func__);
		goto error;
	}

	dev_dbg(&info->client->dev, "%s - ready\n", __func__);

	//data format
	wbuf[0] = MIP4_R0_TEST;
	wbuf[1] = MIP4_R1_TEST_DATA_FORMAT;
	if (mip4_ts_i2c_read(info, wbuf, 2, rbuf, 7)) {
		dev_err(&info->client->dev, "%s [ERROR] Read data format\n", __func__);
		goto error;
	}
	row_num = rbuf[0];
	col_num = rbuf[1];
	buffer_col_num = rbuf[2];
	rotate = rbuf[3];
	key_num = rbuf[4];
	data_type = rbuf[5];
	data_type_sign = (data_type & 0x80) >> 7;
	data_type_size = data_type & 0x7F;
	vector_num = rbuf[6];

	dev_dbg(&info->client->dev, "%s - row_num[%d] col_num[%d] buffer_col_num[%d] rotate[%d] key_num[%d]\n", __func__, row_num, col_num, buffer_col_num, rotate, key_num);
	dev_dbg(&info->client->dev, "%s - data_type[0x%02X] data_type_sign[%d] data_type_size[%d]\n", __func__, data_type, data_type_sign, data_type_size);
	dev_dbg(&info->client->dev, "%s - vector_num[%d]\n", __func__, vector_num);

	if (vector_num > 0) {
		wbuf[0] = MIP4_R0_TEST;
		wbuf[1] = MIP4_R1_TEST_VECTOR_INFO;
		if (mip4_ts_i2c_read(info, wbuf, 2, rbuf, (vector_num * 4))) {
			dev_err(&info->client->dev, "%s [ERROR] Read vector info\n", __func__);
			goto error;
		}
		for (i = 0; i < vector_num; i++) {
			vector_id[i] = rbuf[i * 4 + 0] | (rbuf[i * 4 + 1] << 8);
			vector_elem_num[i] = rbuf[i * 4 + 2] | (rbuf[i * 4 + 3] << 8);
			dev_dbg(&info->client->dev, "%s - vector[%d] : id[%d] elem_num[%d]\n", __func__, i, vector_id[i], vector_elem_num[i]);
		}
	}

	//get buf addr
	wbuf[0] = MIP4_R0_TEST;
	wbuf[1] = MIP4_R1_TEST_BUF_ADDR;
	if (mip4_ts_i2c_read(info, wbuf, 2, rbuf, 2)) {
		dev_err(&info->client->dev, "%s [ERROR] Read buf addr\n", __func__);
		goto error;
	}

	buf_addr_l = rbuf[0];
	buf_addr_h = rbuf[1];
	buf_addr = (buf_addr_h << 8) | buf_addr_l;
	dev_dbg(&info->client->dev, "%s - table buf_addr[0x%02X 0x%02X][0x%04X]\n", __func__, buf_addr_h, buf_addr_l, buf_addr);

	//print data
	table_size = row_num * col_num;
	if (table_size > 0) {
		if (mip4_ts_proc_table_data(info, data_type_size, data_type_sign, buf_addr_h, buf_addr_l, row_num, col_num, buffer_col_num, rotate)) {
			dev_err(&info->client->dev, "%s [ERROR] mip4_ts_proc_table_data\n", __func__);
			goto error;
		}
	}
	if ((key_num > 0) || (vector_num > 0)) {
		if (table_size > 0) {
			buf_addr += (row_num * buffer_col_num * data_type_size);
		}

		buf_addr_l = buf_addr & 0xFF;
		buf_addr_h = (buf_addr >> 8) & 0xFF;
		dev_dbg(&info->client->dev, "%s - vector buf_addr[0x%02X 0x%02X][0x%04X]\n", __func__, buf_addr_h, buf_addr_l, buf_addr);

		if (mip4_ts_proc_vector_data(info, data_type_size, data_type_sign, buf_addr_h, buf_addr_l, key_num, vector_num, vector_id, vector_elem_num, table_size)) {
			dev_err(&info->client->dev, "%s [ERROR] mip4_ts_proc_vector_data\n", __func__);
			goto error;
		}
	}

	//set normal mode
	wbuf[0] = MIP4_R0_CTRL;
	wbuf[1] = MIP4_R1_CTRL_MODE;
	wbuf[2] = MIP4_CTRL_MODE_NORMAL;
	if (mip4_ts_i2c_write(info, wbuf, 3)) {
		dev_err(&info->client->dev, "%s [ERROR] mip4_ts_i2c_write\n", __func__);
		goto error;
	}

	//wait ready status
	wait_cnt = wait_num;
	while (wait_cnt--) {
		if (mip4_ts_get_ready_status(info) == MIP4_CTRL_STATUS_READY) {
			break;
		}
		msleep(10);

		dev_dbg(&info->client->dev, "%s - wait[%d]\n", __func__, wait_cnt);
	}

	if (wait_cnt <= 0) {
		dev_err(&info->client->dev, "%s [ERROR] Wait timeout\n", __func__);
		goto error;
	}

	dev_dbg(&info->client->dev, "%s - set normal mode\n", __func__);

	goto exit;

error:
	ret = 1;

exit:
	mip4_ts_reboot(info);

	//enable touch event
	wbuf[0] = MIP4_R0_CTRL;
	wbuf[1] = MIP4_R1_CTRL_EVENT_TRIGGER_TYPE;
	wbuf[2] = MIP4_CTRL_TRIGGER_INTR;
	if (mip4_ts_i2c_write(info, wbuf, 3)) {
		dev_err(&info->client->dev, "%s [ERROR] Enable event\n", __func__);
		ret = 1;
	}

	mutex_lock(&info->lock);
	info->test_busy = false;
	enable_irq(info->irq);
	mutex_unlock(&info->lock);

	if (!ret) {
		dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
	} else {
		dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
	}

	return ret;
}

/*
* Read image data
*/
int mip4_ts_get_image(struct mip4_ts_info *info, u8 image_type)
{
	int busy_cnt = 500;
	int wait_cnt = 0;
	int wait_num = 200;
	u8 wbuf[8];
	u8 rbuf[512];
	u8 row_num;
	u8 col_num;
	u8 buffer_col_num;
	u8 rotate;
	u8 key_num;
	u8 data_type;
	u8 data_type_size;
	u8 data_type_sign;
	u8 vector_num = 0;
	u16 vector_id[16];
	u16 vector_elem_num[16];
	u8 buf_addr_h;
	u8 buf_addr_l;
	u16 buf_addr;
	int table_size;
	int i;
	int ret = 0;

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);
	dev_dbg(&info->client->dev, "%s - image_type[%d]\n", __func__, image_type);

	while (busy_cnt--) {
		if (info->test_busy == false) {
			break;
		}
		dev_dbg(&info->client->dev, "%s - busy_cnt[%d]\n", __func__, busy_cnt);
		msleep(1);
	}

	mutex_lock(&info->lock);
	disable_irq(info->irq);
	info->test_busy = true;
	mutex_unlock(&info->lock);

	memset(info->print_buf, 0, PAGE_SIZE);

	//disable touch event
	wbuf[0] = MIP4_R0_CTRL;
	wbuf[1] = MIP4_R1_CTRL_EVENT_TRIGGER_TYPE;
	wbuf[2] = MIP4_CTRL_TRIGGER_NONE;
	if (mip4_ts_i2c_write(info, wbuf, 3)) {
		dev_err(&info->client->dev, "%s [ERROR] Disable event\n", __func__);
		goto error;
	}

	//check image type
	switch (image_type) {
	case MIP4_IMG_TYPE_INTENSITY:
		dev_dbg(&info->client->dev, "=== Intensity Image ===\n");
		sprintf(info->print_buf, "\n=== Intensity Image ===\n\n");
		break;
	case MIP4_IMG_TYPE_RAWDATA:
		dev_dbg(&info->client->dev, "=== Rawdata Image ===\n");
		sprintf(info->print_buf, "\n=== Rawdata Image ===\n\n");
		break;
	case MIP4_IMG_TYPE_GESTURE:
		dev_dbg(&info->client->dev, "=== Gesture Image ===\n");
		sprintf(info->print_buf, "\n=== Gesture Image ===\n\n");
		break;
	case MIP4_IMG_TYPE_HSELF_RAWDATA:
		dev_dbg(&info->client->dev, "=== Self Rawdata Image ===\n");
		sprintf(info->print_buf, "\n=== Self Rawdata Image ===\n\n");
		break;
	case MIP4_IMG_TYPE_HSELF_INTENSITY:
		dev_dbg(&info->client->dev, "=== Self Intensity Image ===\n");
		sprintf(info->print_buf, "\n=== Self Intensity Image ===\n\n");
		break;
	default:
		dev_err(&info->client->dev, "%s [ERROR] Unknown image type\n", __func__);
		sprintf(info->print_buf, "\nERROR : Unknown image type\n\n");
		goto error;
		break;
	}

	//set image type
	wbuf[0] = MIP4_R0_IMAGE;
	wbuf[1] = MIP4_R1_IMAGE_TYPE;
	wbuf[2] = image_type;
	if (mip4_ts_i2c_write(info, wbuf, 3)) {
		dev_err(&info->client->dev, "%s [ERROR] Write image type\n", __func__);
		goto error;
	}

	dev_dbg(&info->client->dev, "%s - set image type\n", __func__);

	//wait ready status
	wait_cnt = wait_num;
	while (wait_cnt--) {
		if (mip4_ts_get_ready_status(info) == MIP4_CTRL_STATUS_READY) {
			break;
		}
		msleep(10);

		dev_dbg(&info->client->dev, "%s - wait[%d]\n", __func__, wait_cnt);
	}

	if (wait_cnt <= 0) {
		dev_err(&info->client->dev, "%s [ERROR] Wait timeout\n", __func__);
		goto error;
	}

	dev_dbg(&info->client->dev, "%s - ready\n", __func__);

	//data format
	wbuf[0] = MIP4_R0_IMAGE;
	wbuf[1] = MIP4_R1_IMAGE_DATA_FORMAT;
	if (mip4_ts_i2c_read(info, wbuf, 2, rbuf, 7)) {
		dev_err(&info->client->dev, "%s [ERROR] Read data format\n", __func__);
		goto error;
	}
	row_num = rbuf[0];
	col_num = rbuf[1];
	buffer_col_num = rbuf[2];
	rotate = rbuf[3];
	key_num = rbuf[4];
	data_type = rbuf[5];
	data_type_sign = (data_type & 0x80) >> 7;
	data_type_size = data_type & 0x7F;
	vector_num = rbuf[6];

	dev_dbg(&info->client->dev, "%s - row_num[%d] col_num[%d] buffer_col_num[%d] rotate[%d] key_num[%d]\n", __func__, row_num, col_num, buffer_col_num, rotate, key_num);
	dev_dbg(&info->client->dev, "%s - data_type[0x%02X] data_type_sign[%d] data_type_size[%d]\n", __func__, data_type, data_type_sign, data_type_size);
	dev_dbg(&info->client->dev, "%s - vector_num[%d]\n", __func__, vector_num);

	if (vector_num > 0) {
		wbuf[0] = MIP4_R0_IMAGE;
		wbuf[1] = MIP4_R1_IMAGE_VECTOR_INFO;
		if (mip4_ts_i2c_read(info, wbuf, 2, rbuf, (vector_num * 4))) {
			dev_err(&info->client->dev, "%s [ERROR] Read vector info\n", __func__);
			goto error;
		}
		for (i = 0; i < vector_num; i++) {
			vector_id[i] = rbuf[i * 4 + 0] | (rbuf[i * 4 + 1] << 8);
			vector_elem_num[i] = rbuf[i * 4 + 2] | (rbuf[i * 4 + 3] << 8);
			dev_dbg(&info->client->dev, "%s - vector[%d] : id[%d] elem_num[%d]\n", __func__, i, vector_id[i], vector_elem_num[i]);
		}
	}

	//get buf addr
	wbuf[0] = MIP4_R0_IMAGE;
	wbuf[1] = MIP4_R1_IMAGE_BUF_ADDR;
	if (mip4_ts_i2c_read(info, wbuf, 2, rbuf, 2)) {
		dev_err(&info->client->dev, "%s [ERROR] Read buf addr\n", __func__);
		goto error;
	}

	buf_addr_l = rbuf[0];
	buf_addr_h = rbuf[1];
	buf_addr = (buf_addr_h << 8) | buf_addr_l;
	dev_dbg(&info->client->dev, "%s - table buf_addr[0x%02X 0x%02X][0x%04X]\n", __func__, buf_addr_h, buf_addr_l, buf_addr);

	//print data
	table_size = row_num * col_num;
	if (table_size > 0) {
		if (mip4_ts_proc_table_data(info, data_type_size, data_type_sign, buf_addr_h, buf_addr_l, row_num, col_num, buffer_col_num, rotate)) {
			dev_err(&info->client->dev, "%s [ERROR] mip4_ts_proc_table_data\n", __func__);
			goto error;
		}
	}
	if ((key_num > 0) || (vector_num > 0)) {
		if (table_size > 0) {
			buf_addr += (row_num * buffer_col_num * data_type_size);
		}

		buf_addr_l = buf_addr & 0xFF;
		buf_addr_h = (buf_addr >> 8) & 0xFF;
		dev_dbg(&info->client->dev, "%s - vector buf_addr[0x%02X 0x%02X][0x%04X]\n", __func__, buf_addr_h, buf_addr_l, buf_addr);

		if (mip4_ts_proc_vector_data(info, data_type_size, data_type_sign, buf_addr_h, buf_addr_l, key_num, vector_num, vector_id, vector_elem_num, table_size)) {
			dev_err(&info->client->dev, "%s [ERROR] mip4_ts_proc_vector_data\n", __func__);
			goto error;
		}
	}

	//clear image type
	wbuf[0] = MIP4_R0_IMAGE;
	wbuf[1] = MIP4_R1_IMAGE_TYPE;
	wbuf[2] = MIP4_IMG_TYPE_NONE;
	if (mip4_ts_i2c_write(info, wbuf, 3)) {
		dev_err(&info->client->dev, "%s [ERROR] Clear image type\n", __func__);
		goto error;
	}

	//post process
	if (image_type == MIP4_IMG_TYPE_GESTURE) {
		memcpy(info->debug_buf, info->print_buf, PAGE_SIZE);
	}

	goto exit;

error:
	ret = 1;

exit:
	//enable touch event
	wbuf[0] = MIP4_R0_CTRL;
	wbuf[1] = MIP4_R1_CTRL_EVENT_TRIGGER_TYPE;
	wbuf[2] = MIP4_CTRL_TRIGGER_INTR;
	if (mip4_ts_i2c_write(info, wbuf, 3)) {
		dev_err(&info->client->dev, "%s [ERROR] Enable event\n", __func__);
		ret = 1;
	}

	mutex_lock(&info->lock);
	info->test_busy = false;
	enable_irq(info->irq);
	mutex_unlock(&info->lock);

	if (!ret) {
		dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
	} else {
		dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
	}

	return ret;
}

#endif

#if USE_SYS
/*
* Print chip firmware version
*/
static ssize_t mip4_ts_sys_fw_version(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	u8 data[255];
	int ret;
	u8 rbuf[16];

	if (mip4_ts_get_fw_version(info, rbuf)) {
		dev_err(&info->client->dev, "%s [ERROR] mip4_ts_get_fw_version\n", __func__);

		sprintf(data, "F/W Version : ERROR\n");
		goto error;
	}

	dev_info(&info->client->dev, "%s - F/W Version : %02X.%02X/%02X.%02X/%02X.%02X/%02X.%02X\n", __func__, rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7]);
	sprintf(data, "F/W Version : %02X.%02X/%02X.%02X/%02X.%02X/%02X.%02X\n", rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7]);

error:
	ret = snprintf(buf, 255, "%s\n", data);
	return ret;
}

#if (CHIP_MODEL != CHIP_NONE)
/*
* Update firmware from external storage
*/
static ssize_t mip4_ts_sys_fw_update_from_storage(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct i2c_client *client = to_i2c_client(dev);
	struct mip4_ts_info *info = i2c_get_clientdata(client);
	int result = 0;
	u8 data[255];
	int ret = 0;

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	//Update firmware
	ret = mip4_ts_fw_update_from_storage(info, info->fw_path_ext, true);

	switch (ret) {
	case fw_err_none:
		sprintf(data, "F/W update success.\n");
		break;
	case fw_err_uptodate:
		sprintf(data, "F/W is already up-to-date.\n");
		break;
	case fw_err_download:
		sprintf(data, "F/W update failed : Download error\n");
		break;
	case fw_err_file_type:
		sprintf(data, "F/W update failed : File type error\n");
		break;
	case fw_err_file_open:
		sprintf(data, "F/W update failed : File open error[%s]\n", info->fw_path_ext);
		break;
	case fw_err_file_read:
		sprintf(data, "F/W update failed : File read error\n");
		break;
	default:
		sprintf(data, "F/W update failed.\n");
		break;
	}

	//Re-config driver
	mip4_ts_config(info);
	mip4_ts_config_input(info);

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);

	result = snprintf(buf, 255, "%s\n", data);
	return result;
}

/*
* Set firmware path
*/
static ssize_t mip4_ts_sys_fw_path_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	char *path;

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	if (count <= 1) {
		dev_err(&info->client->dev, "%s [ERROR] Wrong value [%s]\n", __func__, buf);
		goto error;
	}

	path = kzalloc(count - 1, GFP_KERNEL);
	memcpy(path, buf, count - 1);

	info->fw_path_ext = kstrdup(path, GFP_KERNEL);

	dev_dbg(&info->client->dev, "%s - Path : %s\n", __func__, info->fw_path_ext);

	kfree(path);

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
	return count;

error:
	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
	return count;
}

/*
* Print firmware path
*/
static ssize_t mip4_ts_sys_fw_path_show(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	u8 data[255];
	int ret;

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	sprintf(data, "Path : %s\n", info->fw_path_ext);

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);

	ret = snprintf(buf, 255, "%s\n", data);
	return ret;
}

/*
* Print bin(file) firmware version
*/
static ssize_t mip4_ts_sys_bin_version(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	u8 data[255];
	int ret;
	u8 rbuf[16];

	if (mip4_ts_get_fw_version_from_bin(info, rbuf)) {
		dev_err(&info->client->dev, "%s [ERROR] mip4_ts_get_fw_version_from_bin\n", __func__);
		sprintf(data, "BIN Version : ERROR\n");
		goto error;
	}

	dev_info(&info->client->dev, "%s - BIN Version : %02X.%02X/%02X.%02X/%02X.%02X/%02X.%02X\n", __func__, rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7]);
	sprintf(data, "BIN Version : %02X.%02X/%02X.%02X/%02X.%02X/%02X.%02X\n", rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7]);

error:
	ret = snprintf(buf, 255, "%s\n", data);
	return ret;
}
#endif

#if ((CHIP_MODEL == CHIP_MFS10) || (CHIP_MODEL == CHIP_MFS10VE))
/*
* Flash calibration table
*/
static ssize_t mip4_ts_sys_flash_cal_table(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	u8 data[255];
	int ret;

	if (mip4_ts_flash_cal_table(info)) {
		dev_err(&info->client->dev, "%s [ERROR] mip4_ts_flash_cal_table\n", __func__);
		sprintf(data, "ERROR");
		goto error;
	}
	sprintf(data, "DONE");

error:
	ret = snprintf(buf, 255, "%s\n", data);
	return ret;
}
#endif

/*
* Print channel info
*/
static ssize_t mip4_ts_sys_info(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	u8 data[255];
	int ret;
	u8 rbuf[16];
	u8 wbuf[8];
	unsigned int res_x, res_y;
	unsigned int len_x, len_y;
	unsigned int ppm_x, ppm_y;

	memset(info->print_buf, 0, PAGE_SIZE);
	sprintf(info->print_buf, "\n");

	sprintf(info->print_buf, "Device Name : %s\n", MIP4_TS_DEVICE_NAME);

	sprintf(data, "Driver Chip Name : %s\n", CHIP_NAME);
	strcat(info->print_buf, data);

	wbuf[0] = MIP4_R0_INFO;
	wbuf[1] = MIP4_R1_INFO_IC_NAME;
	mip4_ts_i2c_read(info, wbuf, 2, rbuf, 4);
	sprintf(data, "Chip Model Code : %.*s\n", 4, rbuf);
	strcat(info->print_buf, data);

	wbuf[0] = MIP4_R0_INFO;
	wbuf[1] = MIP4_R1_INFO_PRODUCT_NAME;
	mip4_ts_i2c_read(info, wbuf, 2, rbuf, 16);
	sprintf(data, "Product Name : %.*s\n", 16, rbuf);
	strcat(info->print_buf, data);

	mip4_ts_get_fw_version(info, rbuf);
	sprintf(data, "F/W Version : %02X.%02X/%02X.%02X/%02X.%02X/%02X.%02X\n", rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7]);
	strcat(info->print_buf, data);

	wbuf[0] = MIP4_R0_INFO;
	wbuf[1] = MIP4_R1_INFO_RESOLUTION_X;
	mip4_ts_i2c_read(info, wbuf, 2, rbuf, 14);
	res_x = (rbuf[0]) | (rbuf[1] << 8);
	res_y = (rbuf[2]) | (rbuf[3] << 8);
	sprintf(data, "Resolution : X[%d] Y[%d]\n", res_x, res_y);
	strcat(info->print_buf, data);

	len_x = (rbuf[8]) | (rbuf[9] << 8);
	len_y = (rbuf[10]) | (rbuf[11] << 8);
	sprintf(data, "Panel size (dmm) : X[%d] Y[%d]\n", len_x, len_y);
	strcat(info->print_buf, data);

	ppm_x = rbuf[12];
	ppm_y = rbuf[13];
	sprintf(data, "Pixels per mm : X[%d] Y[%d]\n", ppm_x, ppm_y);
	strcat(info->print_buf, data);

	sprintf(data, "Node Num : X[%d] Y[%d] Key[%d]\n", rbuf[4], rbuf[5], rbuf[6]);
	strcat(info->print_buf, data);

	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
	return ret;
}

#ifdef DEBUG
/*
* Power on
*/
static ssize_t mip4_ts_sys_power_on(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	struct i2c_client *client = info->client;
	u8 data[255];
	int ret;

	mip4_ts_power_on(info);

	dev_info(&client->dev, "%s", __func__);

	sprintf(data, "Power : On\n");

	ret = snprintf(buf, 225, "%s\n", data);
	return ret;

}

/*
* Power off
*/
static ssize_t mip4_ts_sys_power_off(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	u8 data[255];
	int ret;

	mip4_ts_power_off(info);

	dev_info(&info->client->dev, "%s", __func__);

	sprintf(data, "Power : Off\n");

	ret = snprintf(buf, 225, "%s\n", data);
	return ret;
}

/*
* Reboot chip
*/
static ssize_t mip4_ts_sys_reboot(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	u8 data[255];
	int ret;

	dev_info(&info->client->dev, "%s", __func__);

	disable_irq(info->irq);
	mip4_ts_clear_input(info);
	mip4_ts_reboot(info);
	enable_irq(info->irq);

	sprintf(data, "Reboot\n");

	ret = snprintf(buf, 255, "%s\n", data);
	return ret;
}
#endif

/*
* Set mode
*/
static ssize_t mip4_ts_sys_mode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	u8 wbuf[8];
	u8 value = 0;

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	wbuf[0] = MIP4_R0_CTRL;

	if (!strcmp(attr->attr.name, "mode_glove")) {
		wbuf[1] = MIP4_R1_CTRL_HIGH_SENS_MODE;
	} else if (!strcmp(attr->attr.name, "mode_charger")) {
		wbuf[1] = MIP4_R1_CTRL_CHARGER_MODE;
	} else if (!strcmp(attr->attr.name, "mode_cover_window")) {
		wbuf[1] = MIP4_R1_CTRL_WINDOW_MODE;
	} else if (!strcmp(attr->attr.name, "mode_palm_rejection")) {
		wbuf[1] = MIP4_R1_CTRL_PALM_REJECTION;
	} else if (!strcmp(attr->attr.name, "mode_edge_correction")) {
		wbuf[1] = MIP4_R1_CTRL_EDGE_CORRECTION;
	} else if (!strcmp(attr->attr.name, "mode_proximity_sensing")) {
		wbuf[1] = MIP4_R1_CTRL_PROXIMITY_SENSING;
	} else if (!strcmp(attr->attr.name, "mode_gesture_debug")) {
		wbuf[1] = MIP4_R1_CTRL_GESTURE_DEBUG;
	} else {
		dev_err(&info->client->dev, "%s [ERROR] Unknown mode[%s]\n", __func__, attr->attr.name);
		goto error;
	}

	if (buf[0] == 48) {
		value = 0;
	}
	else if (buf[0] == 49) {
		value = 1;
	}
	else{
		dev_err(&info->client->dev, "%s [ERROR] Wrong value[%c]\n", __func__, buf[0]);
		goto error;
	}
	wbuf[2] = value;

	if (mip4_ts_i2c_write(info, wbuf, 3)) {
		dev_err(&info->client->dev, "%s [ERROR] mip4_ts_i2c_write\n", __func__);
		goto error;
	} else {
		dev_info(&info->client->dev, "%s - addr[0x%02X%02X] value[%d]\n", __func__, wbuf[0], wbuf[1], value);
	}

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
	return count;

error:
	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
	return count;
}

/*
* Print mode
*/
static ssize_t mip4_ts_sys_mode_show(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	u8 data[255];
	int ret;
	u8 wbuf[8];
	u8 rbuf[4];

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	wbuf[0] = MIP4_R0_CTRL;

	if (!strcmp(attr->attr.name, "mode_glove")) {
		wbuf[1] = MIP4_R1_CTRL_HIGH_SENS_MODE;
	} else if (!strcmp(attr->attr.name, "mode_charger")) {
		wbuf[1] = MIP4_R1_CTRL_CHARGER_MODE;
	} else if (!strcmp(attr->attr.name, "mode_cover_window")) {
		wbuf[1] = MIP4_R1_CTRL_WINDOW_MODE;
	} else if (!strcmp(attr->attr.name, "mode_palm_rejection")) {
		wbuf[1] = MIP4_R1_CTRL_PALM_REJECTION;
	} else if (!strcmp(attr->attr.name, "mode_edge_correction")) {
		wbuf[1] = MIP4_R1_CTRL_EDGE_CORRECTION;
	} else if (!strcmp(attr->attr.name, "mode_proximity_sensing")) {
		wbuf[1] = MIP4_R1_CTRL_PROXIMITY_SENSING;
	} else if (!strcmp(attr->attr.name, "mode_gesture_debug")) {
		wbuf[1] = MIP4_R1_CTRL_GESTURE_DEBUG;
	} else {
		dev_err(&info->client->dev, "%s [ERROR] Unknown mode[%s]\n", __func__, attr->attr.name);
		sprintf(data, "%s : Unknown Mode\n", attr->attr.name);
		goto exit;
	}

	if (mip4_ts_i2c_read(info, wbuf, 2, rbuf, 1)) {
		dev_err(&info->client->dev, "%s [ERROR] mip4_ts_i2c_read\n", __func__);
		sprintf(data, "%s : ERROR\n", attr->attr.name);
	} else {
		dev_info(&info->client->dev, "%s - addr[0x%02X%02X] value[%d]\n", __func__, wbuf[0], wbuf[1], rbuf[0]);
		sprintf(data, "%s : %d\n", attr->attr.name, rbuf[0]);
	}

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);

exit:
	ret = snprintf(buf, 255, "%s\n", data);
	return ret;
}

/*
* Sysfs print image
*/
static ssize_t mip4_ts_sys_image(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	int ret;
	u8 type;

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	if (!strcmp(attr->attr.name, "image_intensity")) {
		type = MIP4_IMG_TYPE_INTENSITY;
	} else if (!strcmp(attr->attr.name, "image_rawdata")) {
		type = MIP4_IMG_TYPE_RAWDATA;
	} else if (!strcmp(attr->attr.name, "image_gesture")) {
		type = MIP4_IMG_TYPE_GESTURE;
	} else if (!strcmp(attr->attr.name, "image_self_rawdata")) {
		type = MIP4_IMG_TYPE_HSELF_RAWDATA;
	} else if (!strcmp(attr->attr.name, "image_self_intensity")) {
		type = MIP4_IMG_TYPE_HSELF_INTENSITY;
	} else {
		dev_err(&info->client->dev, "%s [ERROR] Unknown image[%s]\n", __func__, attr->attr.name);
		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR : Unknown image type");
		goto error;
	}

	if (mip4_ts_get_image(info, type)) {
		dev_err(&info->client->dev, "%s [ERROR] mip4_ts_get_image\n", __func__);
		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR");
		goto error;
	}

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);

	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
	return ret;

error:
	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
	return ret;
}

/*
* Sysfs print debug data
*/
static ssize_t mip4_ts_sys_debug(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	int ret;
	u8 type;

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	if (!strcmp(attr->attr.name, "debug_gesture")) {
		type = MIP4_IMG_TYPE_GESTURE;
	} else {
		dev_err(&info->client->dev, "%s [ERROR] Unknown image[%s]\n", __func__, attr->attr.name);
		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR : Unknown image type");
		goto error;
	}

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);

	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->debug_buf);
	return ret;

error:
	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
	return ret;
}

/*
* Sysfs run test
*/
static ssize_t mip4_ts_sys_test(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	int ret;
	u8 test_type;

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	if (!strcmp(attr->attr.name, "test_cm")) {
		test_type = MIP4_TEST_TYPE_CM;
	} else if (!strcmp(attr->attr.name, "test_cm_abs")) {
		test_type = MIP4_TEST_TYPE_CM_ABS;
	} else if (!strcmp(attr->attr.name, "test_cm_jitter")) {
		test_type = MIP4_TEST_TYPE_CM_JITTER;
	} else if (!strcmp(attr->attr.name, "test_cm_diff_horizontal")) {
		test_type = MIP4_TEST_TYPE_CM_DIFF_HOR;
	} else if (!strcmp(attr->attr.name, "test_cm_diff_vertical")) {
		test_type = MIP4_TEST_TYPE_CM_DIFF_VER;
	} else if (!strcmp(attr->attr.name, "test_cp")) {
		test_type = MIP4_TEST_TYPE_CP;
	} else if (!strcmp(attr->attr.name, "test_cp_low")) {
		test_type = MIP4_TEST_TYPE_CP_LOW;
	} else if (!strcmp(attr->attr.name, "test_cp_high")) {
		test_type = MIP4_TEST_TYPE_CP_HIGH;
	} else if (!strcmp(attr->attr.name, "test_cp_jitter")) {
		test_type = MIP4_TEST_TYPE_CP_JITTER;
	} else if (!strcmp(attr->attr.name, "test_cp_diff_horizontal")) {
		test_type = MIP4_TEST_TYPE_CP_DIFF_HOR;
	} else if (!strcmp(attr->attr.name, "test_cp_diff_vertical")) {
		test_type = MIP4_TEST_TYPE_CP_DIFF_VER;
	} else if (!strcmp(attr->attr.name, "test_cp_short")) {
		test_type = MIP4_TEST_TYPE_CP_SHORT;
	} else if (!strcmp(attr->attr.name, "test_cp_lpm")) {
		test_type = MIP4_TEST_TYPE_CP_LPM;
	} else if (!strcmp(attr->attr.name, "test_short")) {
		test_type = MIP4_TEST_TYPE_SHORT;
	} else {
		dev_err(&info->client->dev, "%s [ERROR] Unknown test[%s]\n", __func__, attr->attr.name);
		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR : Unknown test type");
		goto error;
	}

	if (mip4_ts_run_test(info, test_type)) {
		dev_err(&info->client->dev, "%s [ERROR] mip4_ts_run_test\n", __func__);
		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR");
		goto error;
	}

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);

	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
	return ret;

error:
	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
	return ret;
}

#if ((CHIP_MODEL == CHIP_MIT200) || (CHIP_MODEL == CHIP_MIT300))
#else
#if ((CHIP_MODEL == CHIP_MMS500) || (CHIP_MODEL == CHIP_MFS10) || (CHIP_MODEL == CHIP_MFS10VE) || (CHIP_MODEL == CHIP_MCS8040L))
#else
/*
* Sysfs run short test
*/
static ssize_t mip4_ts_sys_test_short(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	int ret;
	u8 test_type = MIP4_TEST_TYPE_SHORT;
	int ix, iy, idx, ch;
	int cnt = 0;
	char data[10];
	int size = info->node_x + info->node_y + info->node_key;

	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	if (mip4_ts_run_test(info, test_type)) {
		dev_err(&info->client->dev, "%s [ERROR] mip4_ts_run_test\n", __func__);
		ret = snprintf(buf, PAGE_SIZE, "%s\n", "ERROR");
		goto ERROR;
	}

	memset(info->print_buf, 0, PAGE_SIZE);
	strcat(info->print_buf, "\n=== Short Test ===\n\n");

	for (iy = 0; iy < size; iy++) {
		for (ix = (iy + 1); ix < size; ix++) {
			idx = iy * size + ix;

			if (info->image_buf[idx] != 255) {
				cnt++;

				strcat(info->print_buf, "Short : ");

				if (ix < info->node_x) {
					strcat(info->print_buf, "X");
					ch = ix;
				} else if (ix < (info->node_x + info->node_y)) {
					strcat(info->print_buf, "Y");
					ch = ix - info->node_x;
				} else {
					strcat(info->print_buf, "Key");
					ch = ix - (info->node_x + info->node_y);
				}
				memset(data, 0, sizeof(data));
				sprintf(data, "[%d]", ch);
				strcat(info->print_buf, data);

				strcat(info->print_buf, "-");

				if (iy < info->node_x) {
					strcat(info->print_buf, "X");
					ch = iy;
				} else if (iy < (info->node_x + info->node_y)) {
					strcat(info->print_buf, "Y");
					ch = iy - info->node_x;
				} else {
					strcat(info->print_buf, "Key");
					ch = iy - (info->node_x + info->node_y);
				}
				memset(data, 0, sizeof(data));
				sprintf(data, "[%d]", ch);
				strcat(info->print_buf, data);

				memset(data, 0, sizeof(data));
				sprintf(data, " (%d)\n", info->image_buf[idx]);
				strcat(info->print_buf, data);
			}
		}
	}

	if (cnt == 0) {
		strcat(info->print_buf, "Result : Pass\n");
	} else {
		strcat(info->print_buf, "\n");
		strcat(info->print_buf, "Result : Fail\n");
	}

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);

	ret = snprintf(buf, PAGE_SIZE, "%s\n", info->print_buf);
	return ret;

ERROR:
	dev_err(&info->client->dev, "%s [ERROR]\n", __func__);
	return ret;
}
#endif
#endif

/*
* Print wake-up gesture code
*/
#if USE_WAKEUP_GESTURE
static ssize_t mip4_ts_sys_wakeup_gesture(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct mip4_ts_info *info = dev_get_drvdata(dev);
	u8 data[255];
	int ret;

	dev_dbg(&info->client->dev, "%s", __func__);

	sprintf(data, "gesture:%d\n", info->wakeup_gesture_code);

	ret = snprintf(buf, 255, "%s\n", data);
	return ret;
}
#endif

/*
* Sysfs functions
*/
static DEVICE_ATTR(fw_version, S_IRUGO, mip4_ts_sys_fw_version, NULL);
#if (CHIP_MODEL != CHIP_NONE)
static DEVICE_ATTR(fw_update_storage, S_IRUGO, mip4_ts_sys_fw_update_from_storage, NULL);
static DEVICE_ATTR(fw_path, (S_IRUGO | S_IWUSR | S_IWGRP), mip4_ts_sys_fw_path_show, mip4_ts_sys_fw_path_store);
static DEVICE_ATTR(bin_version, S_IRUGO, mip4_ts_sys_bin_version, NULL);
#endif
#if ((CHIP_MODEL == CHIP_MFS10) || (CHIP_MODEL == CHIP_MFS10VE))
static DEVICE_ATTR(flash_cal_table, S_IRUGO, mip4_ts_sys_flash_cal_table, NULL);
#endif
static DEVICE_ATTR(info, S_IRUGO, mip4_ts_sys_info, NULL);
#ifdef DEBUG
static DEVICE_ATTR(power_on, S_IRUGO, mip4_ts_sys_power_on, NULL);
static DEVICE_ATTR(power_off, S_IRUGO, mip4_ts_sys_power_off, NULL);
static DEVICE_ATTR(reboot, S_IRUGO, mip4_ts_sys_reboot, NULL);
#endif
static DEVICE_ATTR(mode_glove, (S_IRUGO | S_IWUSR | S_IWGRP), mip4_ts_sys_mode_show, mip4_ts_sys_mode_store);
static DEVICE_ATTR(mode_charger, (S_IRUGO | S_IWUSR | S_IWGRP), mip4_ts_sys_mode_show, mip4_ts_sys_mode_store);
static DEVICE_ATTR(mode_cover_window, (S_IRUGO | S_IWUSR | S_IWGRP), mip4_ts_sys_mode_show, mip4_ts_sys_mode_store);
static DEVICE_ATTR(mode_palm_rejection, (S_IRUGO | S_IWUSR | S_IWGRP), mip4_ts_sys_mode_show, mip4_ts_sys_mode_store);
static DEVICE_ATTR(mode_edge_correction, (S_IRUGO | S_IWUSR | S_IWGRP), mip4_ts_sys_mode_show, mip4_ts_sys_mode_store);
#if (CHIP_MODEL == CHIP_MCS8040L)
static DEVICE_ATTR(mode_proximity_sensing, (S_IRUGO | S_IWUSR | S_IWGRP), mip4_ts_sys_mode_show, mip4_ts_sys_mode_store);
#endif
#ifdef DEBUG
static DEVICE_ATTR(image_intensity, S_IRUGO, mip4_ts_sys_image, NULL);
static DEVICE_ATTR(image_rawdata, S_IRUGO, mip4_ts_sys_image, NULL);
static DEVICE_ATTR(image_debug, S_IRUGO, mip4_ts_sys_debug, NULL);
#if ((CHIP_MODEL == CHIP_MMS500) || (CHIP_MODEL == CHIP_MFS10))
static DEVICE_ATTR(image_self_rawdata, S_IRUGO, mip4_ts_sys_image, NULL);
static DEVICE_ATTR(image_self_intensity, S_IRUGO, mip4_ts_sys_image, NULL);
#endif
#if ((CHIP_MODEL == CHIP_MFS10VE) || (CHIP_MODEL == CHIP_MCS8040L))
#else
static DEVICE_ATTR(test_cm, S_IRUGO, mip4_ts_sys_test, NULL);
static DEVICE_ATTR(test_cm_abs, S_IRUGO, mip4_ts_sys_test, NULL);
static DEVICE_ATTR(test_cm_jitter, S_IRUGO, mip4_ts_sys_test, NULL);
static DEVICE_ATTR(test_cm_diff_horizontal, S_IRUGO, mip4_ts_sys_test, NULL);
static DEVICE_ATTR(test_cm_diff_vertical, S_IRUGO, mip4_ts_sys_test, NULL);
#endif
#if ((CHIP_MODEL == CHIP_MIT200) || (CHIP_MODEL == CHIP_MIT300) || (CHIP_MODEL == CHIP_MIT400) || (CHIP_MODEL == CHIP_MIT401) || (CHIP_MODEL == CHIP_MIT410))
#else
#if ((CHIP_MODEL == CHIP_MMS500) || (CHIP_MODEL == CHIP_MFS10) || (CHIP_MODEL == CHIP_MFS10VE) || (CHIP_MODEL == CHIP_MCS8040L))
static DEVICE_ATTR(test_cp, S_IRUGO, mip4_ts_sys_test, NULL);
static DEVICE_ATTR(test_cp_low, S_IRUGO, mip4_ts_sys_test, NULL);
static DEVICE_ATTR(test_cp_high, S_IRUGO, mip4_ts_sys_test, NULL);
static DEVICE_ATTR(test_cp_jitter, S_IRUGO, mip4_ts_sys_test, NULL);
static DEVICE_ATTR(test_cp_diff_horizontal, S_IRUGO, mip4_ts_sys_test, NULL);
static DEVICE_ATTR(test_cp_diff_vertical, S_IRUGO, mip4_ts_sys_test, NULL);
static DEVICE_ATTR(test_cp_short, S_IRUGO, mip4_ts_sys_test, NULL);
static DEVICE_ATTR(test_cp_lpm, S_IRUGO, mip4_ts_sys_test, NULL);
#else
static DEVICE_ATTR(test_short, S_IRUGO, mip4_ts_sys_test_short, NULL);
#endif
#endif
#endif
#if USE_WAKEUP_GESTURE
static DEVICE_ATTR(wakeup_gesture, S_IRUGO, mip4_ts_sys_wakeup_gesture, NULL);
#ifdef DEBUG
static DEVICE_ATTR(debug_gesture, S_IRUGO, mip4_ts_sys_debug, NULL);
static DEVICE_ATTR(mode_gesture_debug, (S_IRUGO | S_IWUSR | S_IWGRP), mip4_ts_sys_mode_show, mip4_ts_sys_mode_store);
#endif
#endif

/*
* Sysfs attr list info
*/
static struct attribute *mip4_ts_sys_attr[] = {
	&dev_attr_fw_version.attr,
#if (CHIP_MODEL != CHIP_NONE)
	&dev_attr_fw_update_storage.attr,
	&dev_attr_fw_path.attr,
	&dev_attr_bin_version.attr,
#endif
#if ((CHIP_MODEL == CHIP_MFS10) || (CHIP_MODEL == CHIP_MFS10VE))
	&dev_attr_flash_cal_table.attr,
#endif
	&dev_attr_info.attr,
#ifdef DEBUG
	&dev_attr_power_on.attr,
	&dev_attr_power_off.attr,
	&dev_attr_reboot.attr,
#endif
	&dev_attr_mode_glove.attr,
	&dev_attr_mode_charger.attr,
	&dev_attr_mode_cover_window.attr,
	&dev_attr_mode_palm_rejection.attr,
	&dev_attr_mode_edge_correction.attr,
#if (CHIP_MODEL == CHIP_MCS8040L)
	&dev_attr_mode_proximity_sensing.attr,
#endif
#ifdef DEBUG
	&dev_attr_image_intensity.attr,
	&dev_attr_image_rawdata.attr,
	&dev_attr_image_debug.attr,
#if ((CHIP_MODEL == CHIP_MMS500) || (CHIP_MODEL == CHIP_MFS10))
	&dev_attr_image_self_rawdata.attr,
	&dev_attr_image_self_intensity.attr,
#endif
#if (CHIP_MODEL == CHIP_MFS10VE) || (CHIP_MODEL == CHIP_MCS8040L)
#else
	&dev_attr_test_cm.attr,
	&dev_attr_test_cm_abs.attr,
	&dev_attr_test_cm_jitter.attr,
	&dev_attr_test_cm_diff_horizontal.attr,
	&dev_attr_test_cm_diff_vertical.attr,
#endif
#if ((CHIP_MODEL == CHIP_MIT200) || (CHIP_MODEL == CHIP_MIT300) || (CHIP_MODEL == CHIP_MIT400) || (CHIP_MODEL == CHIP_MIT401) || (CHIP_MODEL == CHIP_MIT410))
#else
#if ((CHIP_MODEL == CHIP_MMS500) || (CHIP_MODEL == CHIP_MFS10) || (CHIP_MODEL == CHIP_MFS10VE) || (CHIP_MODEL == CHIP_MCS8040L))
	&dev_attr_test_cp.attr,
	&dev_attr_test_cp_low.attr,
	&dev_attr_test_cp_high.attr,
	&dev_attr_test_cp_jitter.attr,
	&dev_attr_test_cp_diff_horizontal.attr,
	&dev_attr_test_cp_diff_vertical.attr,
	&dev_attr_test_cp_short.attr,
	&dev_attr_test_cp_lpm.attr,
#else
	&dev_attr_test_short.attr,
#endif
#endif
#endif
#if USE_WAKEUP_GESTURE
	&dev_attr_wakeup_gesture.attr,
#ifdef DEBUG
	&dev_attr_debug_gesture.attr,
	&dev_attr_mode_gesture_debug.attr,
#endif
#endif
	NULL,
};

/*
* Sysfs attr group info
*/
static const struct attribute_group mip4_ts_sys_attr_group = {
	.attrs = mip4_ts_sys_attr,
};

/*
* Create sysfs test functions
*/
int mip4_ts_sysfs_create(struct mip4_ts_info *info)
{
	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	if (sysfs_create_group(&info->client->dev.kobj, &mip4_ts_sys_attr_group)) {
		dev_err(&info->client->dev, "%s [ERROR] sysfs_create_group\n", __func__);
		return -EAGAIN;
	}

	info->print_buf = devm_kzalloc(&info->client->dev, sizeof(u8) * PAGE_SIZE, GFP_KERNEL);
	info->debug_buf = devm_kzalloc(&info->client->dev, sizeof(u8) * PAGE_SIZE, GFP_KERNEL);
	info->image_buf = devm_kzalloc(&info->client->dev, sizeof(int) * PAGE_SIZE, GFP_KERNEL);

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
	return 0;
}

/*
* Remove sysfs test functions
*/
void mip4_ts_sysfs_remove(struct mip4_ts_info *info)
{
	dev_dbg(&info->client->dev, "%s [START]\n", __func__);

	sysfs_remove_group(&info->client->dev.kobj, &mip4_ts_sys_attr_group);

	devm_kfree(&info->client->dev, info->print_buf);
	devm_kfree(&info->client->dev, info->debug_buf);
	devm_kfree(&info->client->dev, info->image_buf);

	dev_dbg(&info->client->dev, "%s [DONE]\n", __func__);
	return;
}
#endif

